WEBVTT

1
00:07:30.260 --> 00:07:34.709
Toni Wahrstätter: Hello, everyone. Let's wait a few more minutes before we start.

2
00:08:40.400 --> 00:08:42.870
Toni Wahrstätter: Perfect, I think we're ready.

3
00:08:48.660 --> 00:08:49.780
Akash | ECH: Yeah, VLA.

4
00:08:52.430 --> 00:09:02.649
Toni Wahrstätter: Great, thank you very much. Hello, everyone. Today is February 11th. Welcome to the EAP7928 breakout call number 11.

5
00:09:02.910 --> 00:09:09.909
Toni Wahrstätter: We have a quite light agenda today, I would say. Of course, I've said that earlier… I've said that before, and it wasn't that light, but…

6
00:09:10.160 --> 00:09:16.880
Toni Wahrstätter: Today, it looks like we only have two items, and of course, some client updates, splash definite updates.

7
00:09:18.230 --> 00:09:26.050
Toni Wahrstätter: let's directly get into it. I've posted the agenda into the chat, so everyone can have a look. The first item would be

8
00:09:27.040 --> 00:09:36.599
Toni Wahrstätter: as usual, every two weeks, getting some updates on the optimizations at clients. We've just launched DEFNet2, it would be great to know

9
00:09:36.730 --> 00:09:42.970
Toni Wahrstätter: from each client team, which optimizations, parallel execution, parallel I.O,

10
00:09:43.080 --> 00:09:52.060
Toni Wahrstätter: and the parallel state route optimization, which of them is already implemented on DEFNet2, and which one can we already use for benchmarking?

11
00:09:54.780 --> 00:09:58.069
Toni Wahrstätter: Maybe we can start with, let's start with Kef.

12
00:10:09.980 --> 00:10:16.999
Toni Wahrstätter: Okay, I see Jared is not in the call today, then… Let's… go for peso.

13
00:10:17.910 --> 00:10:26.369
Karim T. (matkt): Yes, so all of the optimization already. We had some issue, last week with the prefetch, but we fixed that.

14
00:10:26.600 --> 00:10:32.900
Karim T. (matkt): So, for the moment, we have two branches, BaldevNet 2, so in BaldevNet 2, we have…

15
00:10:33.490 --> 00:10:38.840
Karim T. (matkt): parallel execution, state routine background, and we have Baldavinate 2 with this prefetch.

16
00:10:39.030 --> 00:10:44.129
Karim T. (matkt): Where we have state routing background, parall execution, and batch I.O. So…

17
00:10:44.510 --> 00:10:53.140
Karim T. (matkt): I asked Stefan to have two nodes, like that, with a different approach, just in case the prefesh can add some issues.

18
00:10:53.770 --> 00:10:59.480
Karim T. (matkt): But yeah, normally the three implementations are present. We have a first implementation of the prefetch, but…

19
00:10:59.610 --> 00:11:06.679
Karim T. (matkt): Mirgi is working on another optimization, in order to have maybe better performance with the prefetch.

20
00:11:07.010 --> 00:11:08.530
Karim T. (matkt): We'll see later.

21
00:11:08.690 --> 00:11:12.970
Karim T. (matkt): But yeah, for the moment, we have everything, and still trying to optimize more.

22
00:11:16.630 --> 00:11:22.019
Toni Wahrstätter: Okay, this is… this is great to hear. So Beso is essentially at the point where it's fully ready.

23
00:11:22.140 --> 00:11:28.999
Toni Wahrstätter: to be used for any kind of benchmarking. Of course, there might be further optimizations being rolled out, but…

24
00:11:29.120 --> 00:11:32.820
Toni Wahrstätter: In general, the optimizations are there, which is great to hear.

25
00:11:33.220 --> 00:11:34.030
Toni Wahrstätter: Thank you.

26
00:11:35.560 --> 00:11:38.960
Toni Wahrstätter: Let's continue with… Ref?

27
00:11:43.890 --> 00:11:49.460
Dragan Rakita: We are working on that. I think we are missing the parallel execution, and…

28
00:11:49.940 --> 00:11:56.150
Dragan Rakita: I think the team is working on… or at least have something on the parallel state route.

29
00:11:59.230 --> 00:12:04.600
Toni Wahrstätter: Okay, great. What about the I.O? Has that already been worked on, or is that, like…

30
00:12:05.030 --> 00:12:08.359
Toni Wahrstätter: Delayed until after parallel execution state route.

31
00:12:08.990 --> 00:12:11.859
Dragan Rakita: I'm not exactly sure, to be honest.

32
00:12:12.840 --> 00:12:16.240
Dragan Rakita: I think it's delayed, and it will be done later.

33
00:12:16.830 --> 00:12:20.129
Toni Wahrstätter: Okay, yeah, no worries, we can… we can follow up async, too.

34
00:12:20.920 --> 00:12:24.220
Toni Wahrstätter: Let's continue with… with Nethermind.

35
00:12:26.940 --> 00:12:38.640
Marc: Alright, so I'm working on the, parallel execution at the moment, and it's progressing, but yeah, not all the tests are passing yet, so it's not ready for,

36
00:12:39.430 --> 00:12:41.530
Marc: To run tests on yet.

37
00:12:41.630 --> 00:12:52.649
Marc: But yeah, we've mostly just been working on, kind of, getting the, sort of, base implementation, like, kind of tidied up and optimized and ready to merge.

38
00:12:52.800 --> 00:13:06.419
Marc: And also worked on the kind of early, blocking validation, and I found maybe, like, a small thing to discuss with the, optimization around the storage re…

39
00:13:08.040 --> 00:13:14.729
Marc: like, the thing that you would, the document you sent Tony. But yeah, maybe we could, discuss that later.

40
00:13:16.470 --> 00:13:24.270
Toni Wahrstätter: Okay, yeah, let's discuss that, later, it's, it's on the agenda anyway, so… We'll get to that.

41
00:13:24.640 --> 00:13:31.120
Toni Wahrstätter: So, just to summarize, you're working on the parallel execution and patch I.O. and…

42
00:13:31.610 --> 00:13:35.519
Toni Wahrstätter: The parallel state route will then follow afterwards.

43
00:13:36.670 --> 00:13:49.579
Marc: So, more working on the parallel execution. The parallel state route is kind of implemented, but I can't really kind of test if it's fully working until everything's working.

44
00:13:49.700 --> 00:13:57.540
Marc: And then, I think the batch I hadn't started on, but I think it kind of makes sense to do that once the rest is working.

45
00:14:00.360 --> 00:14:02.209
Toni Wahrstätter: Okay, great. Thank you.

46
00:14:04.300 --> 00:14:08.169
Toni Wahrstätter: Dan, do we have someone from Aragon who can give us an update?

47
00:14:22.810 --> 00:14:27.379
Toni Wahrstätter: If no one from Aragon is here, we can also follow up async, I think.

48
00:14:27.650 --> 00:14:43.960
Toni Wahrstätter: Jared arrived in the meantime. Jared, we were already talking about client updates on the optimizations. Do you have a quick update on which optimizations are ready to be tested with Definit2 ready releases, and…

49
00:14:44.300 --> 00:14:45.989
Toni Wahrstätter: Can be used for benchmarking.

50
00:14:47.530 --> 00:14:57.649
Jared Wasinger: Yeah, sure. Yeah, so I've implemented 3, like, performance presets in Geth, so one of them is…

51
00:14:57.970 --> 00:15:01.210
Jared Wasinger: sequential every… like, basically,

52
00:15:02.310 --> 00:15:13.029
Jared Wasinger: sequential execution, and see… and… essentially how Geth executes blocks now, or how Geth…

53
00:15:13.310 --> 00:15:16.449
Jared Wasinger: Would execute a block without,

54
00:15:17.940 --> 00:15:25.209
Jared Wasinger: a block that posts Amsterdam that doesn't contain an access list, and then another one is,

55
00:15:25.530 --> 00:15:32.659
Jared Wasinger: We have parallel execution, parallel, state root calculation, and then…

56
00:15:32.910 --> 00:15:43.030
Jared Wasinger: The async loading of, state reported as, accesses in the access list?

57
00:15:43.910 --> 00:15:50.539
Jared Wasinger: And then there's also an option that's a variant of this, except disabling the…

58
00:15:51.450 --> 00:15:55.220
Jared Wasinger: batch I.O. is what it's being called,

59
00:15:56.810 --> 00:16:04.799
Jared Wasinger: So, 3 of the… all 3 of these presets are, able to be enabled via flags.

60
00:16:05.160 --> 00:16:07.010
Jared Wasinger: The…

61
00:16:08.070 --> 00:16:14.449
Jared Wasinger: So I've been testing this on one of the nodes on the DevNet, and there seems to be some kind of issue…

62
00:16:14.880 --> 00:16:22.930
Jared Wasinger: Because I've also coupled these changes with some fixes to the miner, or to the payload building, and there's some…

63
00:16:23.890 --> 00:16:27.640
Jared Wasinger: issue with block building that,

64
00:16:29.050 --> 00:16:32.399
Jared Wasinger: I'm still working to address right now.

65
00:16:36.780 --> 00:16:40.420
Jared Wasinger: So, yeah, that's kind of the update for Geth.

66
00:16:42.280 --> 00:16:43.740
Toni Wahrstätter: Awesome, thanks a lot.

67
00:16:44.240 --> 00:16:50.410
Toni Wahrstätter: This sounds like, Basel and GEF are essentially ready to be used for benchmarking.

68
00:16:50.610 --> 00:16:54.400
Toni Wahrstätter: And the other clients are also getting there, which is great to hear.

69
00:16:59.830 --> 00:17:04.789
Toni Wahrstätter: Yeah, would be great, Charity, if you could let, Stefan know which flags,

70
00:17:05.430 --> 00:17:10.480
Toni Wahrstätter: to be used for CAF, such that Stefan can add it to his stock, that is very useful.

71
00:17:12.349 --> 00:17:13.359
Toni Wahrstätter: Awesome.

72
00:17:13.560 --> 00:17:19.609
Toni Wahrstätter: But this brings us to the DevNet updates already. Maybe, Stefan, could you give us a…

73
00:17:19.900 --> 00:17:24.939
Toni Wahrstätter: A quick update on the… on the DevNet, how everything's going, and your plans.

74
00:17:25.390 --> 00:17:31.739
Stefan Starflinger: Yeah, sure. So, it's been going pretty well now. It was a little bit…

75
00:17:31.890 --> 00:17:36.730
Stefan Starflinger: I think Nethermind had some small issues, and REST some small issues in the beginning.

76
00:17:36.900 --> 00:17:43.430
Stefan Starflinger: But I think it's going pretty well. Just now, we got an awesome block on REST that might be worth looking into.

77
00:17:43.610 --> 00:17:45.660
Stefan Starflinger: But I think in general, we're…

78
00:17:45.800 --> 00:17:59.620
Stefan Starflinger: pretty stable. Still some tests that would be good to look into. I also saw that the testing team needs to rebase something so that PR from NetherMind will go through.

79
00:18:00.070 --> 00:18:05.430
Stefan Starflinger: But otherwise, I'm looking into how exactly we can do the benchmarking, so just…

80
00:18:05.600 --> 00:18:12.270
Stefan Starflinger: Doing, like, the sanity checking, it's probably not the best environment, the bell.

81
00:18:12.630 --> 00:18:30.289
Stefan Starflinger: Definitely too to have benchmarks that are gonna be used to make any decisions on, but it would be great if we could have everything ready and know exactly how we want to benchmark, so that everything will be working when we actually do

82
00:18:30.360 --> 00:18:34.440
Stefan Starflinger: For example, a shadow fork later when all the clients are ready.

83
00:18:34.860 --> 00:18:40.829
Stefan Starflinger: So right now, I started, just looking, at the Promethos metrics.

84
00:18:41.140 --> 00:18:48.830
Stefan Starflinger: To get some insights, so if there's any metrics that you'd like to add, or that you're still adding.

85
00:18:49.230 --> 00:18:57.909
Stefan Starflinger: that I can then include into some analysis, some sanity check, to see if some optimizations are actually making

86
00:18:58.120 --> 00:19:06.429
Stefan Starflinger: execution faster. It would be great if you could give me some information on that. I see Joachim, you're raising your hand.

87
00:19:07.460 --> 00:19:22.939
jochem-brouwer: Yeah, I wanted to raise one general point about benchmarking, because I think there are… for the block access list, there are two ways, or maybe even three ways, to think about the benchmarking here. The most obvious one is about the execution.

88
00:19:23.040 --> 00:19:29.379
jochem-brouwer: So, what the benchmark there does is you check if clients have reached

89
00:19:29.740 --> 00:19:41.810
jochem-brouwer: a certain level of optimizations utilizing the block access list, and the most obvious one is parallel execution. But there's also this other benchmark, or…

90
00:19:42.260 --> 00:19:47.370
jochem-brouwer: benchmarks as a problem, what we might turn into. It has to do with the sync.

91
00:19:47.600 --> 00:19:56.960
jochem-brouwer: And this is something which we should also benchmark, because if a client falls behind, And,

92
00:19:57.300 --> 00:20:08.719
jochem-brouwer: Sorry, it's not falling behind, but the chain is reorgan. If it then has to reconstruct the chain, but it has to…

93
00:20:08.850 --> 00:20:17.509
jochem-brouwer: request blocks over DevP2P. This means that these blocks do not have the block access list, so you cannot utilize the parallel execution.

94
00:20:17.660 --> 00:20:26.290
jochem-brouwer: And then the question is about, like, how do we benchmark slash test the syncing process in that case?

95
00:20:26.440 --> 00:20:37.279
jochem-brouwer: And I think, you mean here mostly benchmarking the execution part, but I wanted to mention that there are other scenarios which we should also test slash benchmark.

96
00:20:37.890 --> 00:20:47.879
Stefan Starflinger: I think if we benchmark the execution part, I think that's already a very good step in the direction of benchmarking the syncing, because the syncing is just…

97
00:20:47.890 --> 00:20:59.549
Stefan Starflinger: I guess the execution, multiple times in a row, because you just apply all of the blocks quickly. But in general, yes, we should for sure test that as well. We have the sync core.

98
00:20:59.650 --> 00:21:10.529
Stefan Starflinger: for that, so maybe we can add something there, but in general, I think the first step, from my perspective, would be how can we combine it with a benchmarker that,

99
00:21:12.190 --> 00:21:14.500
Stefan Starflinger: guy that Rafael is currently building.

100
00:21:14.870 --> 00:21:21.930
Stefan Starflinger: And I think we should spend some time there, to see that we can capture and test those metrics.

101
00:21:23.540 --> 00:21:32.740
Karim T. (matkt): Also, I think when we talk about printing block access deeds, we said we should keep a minimum amount of block access deeds without… before the printing.

102
00:21:32.950 --> 00:21:37.909
Karim T. (matkt): So I think if a node is behind, it should be able to do parallelization.

103
00:21:39.540 --> 00:21:43.190
Karim T. (matkt): So, if you are… if your node is really stopped during a…

104
00:21:43.450 --> 00:21:50.260
Karim T. (matkt): A lot of weeks, maybe, it will be a problem, but if it's just some blocks, I think you will be able to retrieve block access lists from other peers.

105
00:21:51.680 --> 00:21:58.820
Toni Wahrstätter: Right, yeah. Yeah, just to get back, Johan, to your direct example, exactly what Kareem just said.

106
00:21:59.190 --> 00:22:15.200
Toni Wahrstätter: there will be, so your EL clients keep enough block lab access lists around to always be able to serve you block lab access lists until the week's objectivity period, which is roughly, yeah, a little bit over two weeks.

107
00:22:15.520 --> 00:22:33.299
Toni Wahrstätter: So in that period, you will always be able to, re-execute, and if you fall further behind than the weak subjectivity period, then you need a checkpoint anyway. So at that point, you would need to do the snap sync or something, or apply the ball, basically, to your state.

108
00:22:33.550 --> 00:22:43.179
Toni Wahrstätter: But within the week's subjectivity period, so for roughly 2 weeks, you will always be able to have the same execution speed as if you would just execute at the head.

109
00:22:44.620 --> 00:22:45.960
jochem-brouwer: Yes, but… But I definitely…

110
00:22:45.960 --> 00:22:47.049
Toni Wahrstätter: Yeah, go ahead.

111
00:22:47.050 --> 00:23:04.080
jochem-brouwer: Yeah, yeah, okay, maybe I'm just thinking, like, about the incorrect way, but if the chain is reorging, and we are, we are not getting the blocks over… via the CL, so via the engine API, but instead we have to request the blocks over DevP2P,

112
00:23:04.140 --> 00:23:08.600
jochem-brouwer: In that case, we do not get access to the block access list, right?

113
00:23:10.980 --> 00:23:19.139
Toni Wahrstätter: Why not? So every block would still be mapped to a block lab access list. Of course, if you reorg a block, then you would also have to reorg the…

114
00:23:19.640 --> 00:23:23.919
Toni Wahrstätter: attached access list, but I'm not seeing why this is a problem.

115
00:23:24.650 --> 00:23:25.219
jochem-brouwer: Okay, yeah.

116
00:23:26.140 --> 00:23:34.970
jochem-brouwer: might have to do some more research, but I thought that if you… if you reorg and you have to, like, especially if you request a box over DevP2P, then you do not have the book.

117
00:23:34.970 --> 00:23:35.660
Marius van der Wijden: You're welcome.

118
00:23:35.940 --> 00:23:36.510
jochem-brouwer: Yeah.

119
00:23:36.510 --> 00:23:44.550
Marius van der Wijden: Johann, the blocks are available via DevP2P, or at least they should be with ETH71, right?

120
00:23:45.020 --> 00:23:51.539
jochem-brouwer: Yes, but the block access is not part of the block body, right? So it will not be sent.

121
00:23:51.540 --> 00:24:09.090
Toni Wahrstätter: You would just request it separately, and then directly verify what you got against the header, because the bul hashes in the header. So you would request from DevP2P, and then hash it, compare it against the header, and as of that moment, you know it's part of this block.

122
00:24:10.560 --> 00:24:18.200
jochem-brouwer: Right, but then still, the block access is not part of the block body, so it is not part of the DevB2P response.

123
00:24:19.070 --> 00:24:24.479
Toni Wahrstätter: Not of that… of that request, yeah. There is a new… there is a new EVE71…

124
00:24:25.130 --> 00:24:25.900
jochem-brouwer: Yo!

125
00:24:25.900 --> 00:24:28.919
Toni Wahrstätter: It's not yet merged, but there is a def P2P PR.

126
00:24:29.640 --> 00:24:30.960
jochem-brouwer: I see. Okay, then, yeah.

127
00:24:30.960 --> 00:24:37.730
Toni Wahrstätter: So there's a new method, like getReceipts, get bodies, getHead, and then there is getBAL, or get block access list.

128
00:24:38.090 --> 00:24:47.289
jochem-brouwer: Okay, cool. Yeah, then, for this, for that, process, we would need… we would require EF71. Yeah, okay, cool. I was not aware of this, EF71.

129
00:24:47.330 --> 00:24:58.890
Toni Wahrstätter: This is going so fast, like, we get EV70 and only EV71. Yeah, I just… I just pumped the version yesterday, so it was… it was… the PR had EVE70 previously, and now it's EVE71.

130
00:24:59.160 --> 00:25:10.129
Toni Wahrstätter: I don't think clients have implemented that yet, but yeah, this might be needed exactly for the reasons we just discussed, to enable your node to catch up

131
00:25:10.440 --> 00:25:12.970
Toni Wahrstätter: In case it needs to do beacon sync.

132
00:25:14.460 --> 00:25:16.309
jochem-brouwer: Yep, cool, cool, nice, great.

133
00:25:19.370 --> 00:25:23.300
Toni Wahrstätter: Awesome. Is there anything else, regarding that topic that we should discuss?

134
00:25:24.400 --> 00:25:30.480
Toni Wahrstätter: I know that FP2P spec has not yet merged, so we might… I might want to get that merged soon.

135
00:25:31.140 --> 00:25:36.439
Toni Wahrstätter: So that, clients can actually start implementing it, and we have it at definite free.

136
00:25:40.000 --> 00:25:44.060
Toni Wahrstätter: Or is anyone… Opposed to that.

137
00:25:49.390 --> 00:25:54.679
Toni Wahrstätter: I guess this depends a little bit on the process, right? Because ETH70 is not yet, rolled out.

138
00:25:54.980 --> 00:26:02.199
Toni Wahrstätter: So we might not be able to roll out E71 in this case, but yeah, I will have to double-check with that P2P people.

139
00:26:04.700 --> 00:26:07.079
Toni Wahrstätter: Anything else on that topic?

140
00:26:11.990 --> 00:26:17.670
jochem-brouwer: Yeah, I can maybe chime in on Stephen's question about the benchmarking and the testing.

141
00:26:21.350 --> 00:26:22.930
Toni Wahrstätter: Yeah, please go ahead. Yep.

142
00:26:22.930 --> 00:26:25.760
jochem-brouwer: Yeah. Yeah, so,

143
00:26:25.880 --> 00:26:32.590
jochem-brouwer: So we have this, the east benchmarking, so, east benchmarks are basically just east tests.

144
00:26:32.750 --> 00:26:36.759
jochem-brouwer: Being written, and we run these in the benchmarker.

145
00:26:37.100 --> 00:26:44.129
jochem-brouwer: And this benchmark is a tool where, well, the output of this tool is how fast your blocks run.

146
00:26:44.430 --> 00:26:55.460
jochem-brouwer: What we need for the book access list is we need to write, benchmarks specifically for book access lists. And the reason for this is that,

147
00:26:55.760 --> 00:27:10.790
jochem-brouwer: currently, most tests, they can already be run in parallel, because transactions, they do not interact with each other. So we need to write specific tests, which mean you have to optimize specific parts of your client.

148
00:27:10.970 --> 00:27:17.229
jochem-brouwer: In order to check that you have, you are doing this optimization correctly.

149
00:27:17.670 --> 00:27:21.559
jochem-brouwer: I'm not sure, because I think…

150
00:27:21.710 --> 00:27:30.729
jochem-brouwer: But correct me if I'm wrong, I think, Philippe, you wanted to help or take this on, in ease to write these, tests? Is that correct?

151
00:27:33.120 --> 00:27:41.609
felipe: Yeah, yeah, I'm definitely happy to help here. One of the first steps that we need is to be able to fill for Amsterdam.

152
00:27:42.230 --> 00:27:45.799
felipe: And… Thanks to Spencer.

153
00:27:46.400 --> 00:27:51.289
felipe: and some of… some of the work that I did building on that yesterday, I… we are…

154
00:27:51.830 --> 00:27:54.530
felipe: I posted in the chat here, but…

155
00:27:54.820 --> 00:28:02.589
felipe: We have some development branches of Geth that we're able to fill for Amsterdam now, so we can start, concentrating

156
00:28:02.780 --> 00:28:04.819
felipe: On writing some benchmark tests.

157
00:28:05.000 --> 00:28:07.520
felipe: that are bowel-specific.

158
00:28:08.330 --> 00:28:12.600
felipe: And really start, kind of, kind of testing

159
00:28:13.100 --> 00:28:16.560
felipe: The benchmarks there now, which is… which is great, so…

160
00:28:18.420 --> 00:28:31.089
felipe: But yeah, as far as I know, you had some, some earlier thoughts on… on how to, how to, write benchmark tests for… specifically for bells that don't allow other sorts of parallelizations, right?

161
00:28:32.490 --> 00:28:42.429
jochem-brouwer: Yes, yeah, I'm just seeing your chat indeed, yeah. Yes, so we have to specifically think, like, how can we… you can think of these tests in two ways, like.

162
00:28:42.460 --> 00:28:48.850
jochem-brouwer: how can we write, like, very optimal block access list, tests?

163
00:28:48.870 --> 00:29:02.759
jochem-brouwer: which would then run, like, very nice, or how can we actually abuse the optimization system? And that's, of course, what we want to test and what we want to do, because we do not want to, that clients implement, like, very greedy optimizations, which can be abused.

164
00:29:02.980 --> 00:29:16.289
jochem-brouwer: So, these tests, they have to be written, and these tests are then converted into this benchmark format, and we can then execute these for benchmarks. But for this, there is one…

165
00:29:16.930 --> 00:29:19.119
jochem-brouwer: a thing I'm not…

166
00:29:20.220 --> 00:29:35.720
jochem-brouwer: entirely getting, because this, the benchmark, what it does is it matches the time of the new payload and the fork choice update. And I see in the engine API that, of the new, the new payloads, the block access list is part of it.

167
00:29:36.130 --> 00:29:42.950
jochem-brouwer: And I was slightly confused by this, but maybe I'm not… anymore.

168
00:29:44.190 --> 00:29:47.390
jochem-brouwer: No, that's… that's actually Phil… that's actually right.

169
00:29:47.700 --> 00:29:51.720
Toni Wahrstätter: You're correct, yeah. The policy is in the execution payload.

170
00:29:52.120 --> 00:29:57.210
jochem-brouwer: Yes, yeah, you are right, yeah, yeah, that makes sense.

171
00:29:57.370 --> 00:30:00.100
jochem-brouwer: What did I want to check here?

172
00:30:01.610 --> 00:30:05.969
jochem-brouwer: Yes, so, oh, where are my notes?

173
00:30:07.150 --> 00:30:16.899
jochem-brouwer: Yes, so there are 3 things, or maybe even 4 things here, what we need to benchmark and check. So, as I said in previous discussions also, that

174
00:30:16.900 --> 00:30:29.020
jochem-brouwer: there is this implicit part of this EIP that it unlocks, and it also somewhat makes it mandatory that clients implement these optimizations, and the most obvious one is the parallel execution.

175
00:30:29.030 --> 00:30:37.239
jochem-brouwer: What we should do here is, write benchmarks, which would normally perform, like, very bad.

176
00:30:37.610 --> 00:30:48.769
jochem-brouwer: on clients, for these three optimizations. So we have parallel execution, we have the, the parallel state route calculation, so you don't have to execute transactions, you can just calculate the state route.

177
00:30:48.770 --> 00:30:56.000
jochem-brouwer: Without, executing anything. And, of course, the prefetcher, and for this prefetcher, the most obvious case would be, like, to…

178
00:30:56.000 --> 00:31:10.850
jochem-brouwer: to access or to edit as many storage slots as possible. And there is one thing… This is why I got slightly confused, I think. Because I initially thought that we can easily benchmark this by

179
00:31:10.910 --> 00:31:20.599
jochem-brouwer: Providing clients with either the data which has the block access list, and also the one where we don't have access to the block access list.

180
00:31:22.190 --> 00:31:37.809
jochem-brouwer: But this is not possible, because in the benchmarker, we execute the new payload, and the focus updated, and we therefore always have the block access list available. But I also know that clients expose these optimizations via a flag.

181
00:31:38.690 --> 00:31:44.489
jochem-brouwer: And I think that will be then the way to test this. So what we will do is we test the client.

182
00:31:46.570 --> 00:31:57.000
jochem-brouwer: configured without these optimizations, and a client with these optimizations, and then the difference between these two, that should give an indication if the optimization is

183
00:31:57.120 --> 00:32:01.290
jochem-brouwer: Implemented correctly, if that, makes sense.

184
00:32:03.190 --> 00:32:05.809
Toni Wahrstätter: Yeah, exactly, this makes a lot of sense.

185
00:32:05.950 --> 00:32:13.629
Toni Wahrstätter: Also, what she said about the test cases, that we should think about the freedom from parallelizations and have test cases individually

186
00:32:13.740 --> 00:32:16.229
Toni Wahrstätter: Crafted for each of those.

187
00:32:16.420 --> 00:32:19.829
Toni Wahrstätter: Makes a lot of sense, yeah. Thanks a lot for the update.

188
00:32:20.710 --> 00:32:33.120
jochem-brouwer: Yeah, and there's one final comment I wanted to make that's about the sync process, so we should also think a little bit, like, how are we going to test, because this is, I think, like, very, very important.

189
00:32:33.240 --> 00:32:42.209
jochem-brouwer: Because this VORG situation, we also need this in combination then, we need to test this in combination with EVE71.

190
00:32:42.450 --> 00:32:45.829
jochem-brouwer: Because, in this case,

191
00:32:46.080 --> 00:33:05.370
jochem-brouwer: without EVE71, then this is a situation where a client falls behind, it has to, or doesn't really fall behind, but it has to reorg, but now it does not have access to these block access lists if you are not on EVE71. So this means that block access is implicitly, also mandate that clients implement EVE71.

192
00:33:05.620 --> 00:33:15.620
jochem-brouwer: And we should also test this, and oh yeah, because, Stefan, you talked about… you just talked about this Syncor thing. I am not… I was not aware of this tool.

193
00:33:15.730 --> 00:33:26.499
jochem-brouwer: But do you think we could, like, integrate some kind of setup with Syncore and Benchmarker to also, well, benchmark the Syncore, if that makes sense?

194
00:33:27.720 --> 00:33:38.069
Stefan Starflinger: I'll have to get back to you on that. I'm not sure if those two tools are compatible. In general, Syncro just tries to do a checkpoint sync.

195
00:33:38.490 --> 00:33:42.229
Stefan Starflinger: But maybe we can have something running

196
00:33:42.490 --> 00:33:46.539
Stefan Starflinger: As well, that can capture some benchmarks during that time.

197
00:33:47.780 --> 00:33:59.149
jochem-brouwer: Yeah, okay, yeah, yeah, yeah, so just to clarify what we want to benchmark in this situation is, like, the reorg situation, that clients have to, fetch these blocks over DevP2P.

198
00:33:59.150 --> 00:34:17.560
jochem-brouwer: and therefore also have to fetch these block access lists over the FP2P. Because in this situation, if you do not fetch the block access list, then you cannot do the parallel execution, you also cannot do the statehood calculation without executing the transactions. And that just means that in the worst-case situation, we have, like, a very bad performance impact.

199
00:34:17.670 --> 00:34:27.149
jochem-brouwer: Because if you say block access, they unlock, like, 4 times or whatever execution speed, then in this case, that's not possible if you do not have the

200
00:34:27.280 --> 00:34:33.569
jochem-brouwer: block access lists, and… Therefore, this should definitely be part, also, of the benchmark effort.

201
00:34:40.070 --> 00:34:41.590
Toni Wahrstätter: Right. Yeah.

202
00:34:42.770 --> 00:34:45.499
Toni Wahrstätter: Yeah, I think it's fair to assume that,

203
00:34:46.139 --> 00:35:01.289
Toni Wahrstätter: we… in any case, we always need to guarantee that the block of access lists are available for re-execution, at least within the accept activity period. But definitely worth to… to have that, figured out. And yeah, as Stefan said.

204
00:35:01.400 --> 00:35:06.229
Toni Wahrstätter: the sink coal… Might be the right opportunity there.

205
00:35:06.500 --> 00:35:10.589
Toni Wahrstätter: To have a focused session on how to use BALS for syncing.

206
00:35:11.870 --> 00:35:15.250
Toni Wahrstätter: I see there is a question in the chat.

207
00:35:20.950 --> 00:35:22.710
Toni Wahrstätter: Right. Yeah.

208
00:35:23.990 --> 00:35:33.329
Toni Wahrstätter: As also, I'm just reading the chat, we have to… we have to be smart about, how to benchmark the clients in order to make sure that

209
00:35:33.900 --> 00:35:41.350
Toni Wahrstätter: Yeah, the environment we set up is similar for each client, so not, like, have them fight over course or threats.

210
00:35:44.750 --> 00:35:53.749
Toni Wahrstätter: Great, is there anything else regarding the benchmarking? So, just to summarize, BSW and GAF are essentially, benchmark

211
00:35:53.860 --> 00:35:57.990
Toni Wahrstätter: ready. Other clients are… Getting there.

212
00:35:59.120 --> 00:36:11.969
Toni Wahrstätter: We would probably be able to benchmark execution-related things on the DevNet directly. For state-related stuff, we would probably need a shadow port, but it's… yeah, it's good that we

213
00:36:12.080 --> 00:36:15.519
Toni Wahrstätter: have Definite2 now going, and clients are…

214
00:36:15.760 --> 00:36:27.589
Toni Wahrstätter: Ringing out the last bugs, so that we then, when it comes to shadowing, shadow forking mainnet, there are no bugs that actually directly kill the… kill the network.

215
00:36:29.920 --> 00:36:30.820
Toni Wahrstätter: Great.

216
00:36:31.020 --> 00:36:34.180
Toni Wahrstätter: Anything else on that topic? Yeah, go ahead.

217
00:36:34.970 --> 00:36:39.820
Łukasz Rozmej: About ETH71, so,

218
00:36:40.440 --> 00:36:54.579
Łukasz Rozmej: I understood that it's defined that there's a separate message for getting the balls. Maybe when we request block bodies, if balls are available, they should just be returned in that message.

219
00:36:56.220 --> 00:36:57.750
Łukasz Rozmej: Is that possible?

220
00:36:58.140 --> 00:37:01.149
Toni Wahrstätter: That, that's possible too, of course. I was, I was…

221
00:37:01.150 --> 00:37:02.119
Łukasz Rozmej: It would be easier.

222
00:37:02.120 --> 00:37:05.549
Toni Wahrstätter: Probably be cleaner to keep them separate, because they're not…

223
00:37:05.800 --> 00:37:08.139
Toni Wahrstätter: part of the EL block body.

224
00:37:08.300 --> 00:37:15.060
Toni Wahrstätter: Right, so it's actually conceptually… You would actually go into different databases, right?

225
00:37:15.590 --> 00:37:19.509
Łukasz Rozmej: Okay, so it depends, really,

226
00:37:21.070 --> 00:37:27.800
Łukasz Rozmej: Yeah, to some extent you're right, but in case of implementing,

227
00:37:28.100 --> 00:37:48.040
Łukasz Rozmej: pipeline that gets blocks and processes them, it's easier to have them just in one place, right, if they are available in one message, rather than, okay, those messages already returned a few blocks I want to process, but now I haven't got access list for them yet.

228
00:37:48.130 --> 00:37:54.990
Łukasz Rozmej: So I'm kind of blocked here, it's… Yeah, it's somewhat less…

229
00:37:55.220 --> 00:37:57.240
Toni Wahrstätter: More complex, right?

230
00:37:57.720 --> 00:38:00.690
Toni Wahrstätter: But that would be a bug, right? Because if a…

231
00:38:01.230 --> 00:38:09.929
Toni Wahrstätter: if someone provides you a block body, but not an access list, this is, like, a weird situation. It's almost like a peer gives you a body, but no receipt.

232
00:38:10.730 --> 00:38:17.419
Łukasz Rozmej: Networking is unstable, right? So, maybe those packets got lost, maybe something, right?

233
00:38:18.550 --> 00:38:23.669
Toni Wahrstätter: Right, but it would be essentially the same if the client doesn't provide you the receipts or something, right?

234
00:38:24.580 --> 00:38:37.669
Łukasz Rozmej: Yes, to some extent, yes. So, maybe it's not that big deal, but it will make implementations more complicated a bit. Not maybe not something to worry about too much, but…

235
00:38:38.180 --> 00:38:39.020
Łukasz Rozmej: Fine.

236
00:38:40.140 --> 00:38:40.800
Toni Wahrstätter: Yeah.

237
00:38:40.980 --> 00:38:46.050
Toni Wahrstätter: Okay, yeah, thanks a lot, good to know, definitely chime in in the…

238
00:38:46.630 --> 00:38:58.290
Toni Wahrstätter: DeafP2P PR that I created. I can post it into the chat as soon as I find it. There's currently still some discussion about the PR,

239
00:38:58.660 --> 00:39:01.820
Toni Wahrstätter: how to best proceed, I posted it into the chat now.

240
00:39:02.030 --> 00:39:05.730
Toni Wahrstätter: So, yeah, feel free to chime in there, voice your opinion.

241
00:39:06.020 --> 00:39:09.509
Toni Wahrstätter: I also, proposed,

242
00:39:09.980 --> 00:39:24.080
Toni Wahrstätter: yeah, some optimizations, how the ball could be, how we could kind of filter out the reads from the ball when it comes to the FP2P, that might be kind of simple to add, but nothing to bring up today in this call, so feel free to have a look.

243
00:39:25.090 --> 00:39:27.729
Toni Wahrstätter: Regarding the FP2P PR.

244
00:39:30.550 --> 00:39:35.530
jochem-brouwer: Yeah, one… Awesome. Sorry, again.

245
00:39:35.680 --> 00:39:47.369
jochem-brouwer: Can I also add these to, as a networking EIP? Because I was looking at the EIPs, and I could not find it, and, like, in DevPTP, it's the correct location, but it should also have an EIP for each71.

246
00:39:49.050 --> 00:39:55.980
Toni Wahrstätter: Okay, yeah, if that's the… the, best practices there, I will… I will be…

247
00:39:55.980 --> 00:39:56.350
jochem-brouwer: Yep.

248
00:39:56.350 --> 00:39:57.100
Toni Wahrstätter: to do so.

249
00:39:57.800 --> 00:39:58.970
jochem-brouwer: Google. Perfect.

250
00:40:01.280 --> 00:40:02.570
Toni Wahrstätter: Anything else?

251
00:40:08.500 --> 00:40:13.030
Toni Wahrstätter: Otherwise, we would proceed with the next agenda item, which would be…

252
00:40:13.210 --> 00:40:19.639
Toni Wahrstätter: The early biorejection topics we discussed two weeks ago.

253
00:40:19.760 --> 00:40:22.330
Toni Wahrstätter: Mark already brought it up today,

254
00:40:22.870 --> 00:40:33.149
Toni Wahrstätter: Just to summarize, two optimizations were two different things. One of them was very simple cap on the items in the bowl. So basically, each item in the bowl

255
00:40:33.290 --> 00:40:40.559
Toni Wahrstätter: Costs at least, 2,000 gas to access with today's prices. That's the…

256
00:40:40.970 --> 00:40:47.729
Toni Wahrstätter: The cost to put an item on the access list, and the cost to access a warm state location.

257
00:40:47.970 --> 00:41:06.129
Toni Wahrstätter: So that's 2,000 gas. And based on that, you can already tell if a block is invalid or not, because if the bar claims to access more items than the gas limit would allow, then clients should already invalidate the block. And to make sure this is, like, a strict

258
00:41:06.460 --> 00:41:11.509
Toni Wahrstätter: requirement, I would suggest we put that into the… into the specs.

259
00:41:11.760 --> 00:41:14.629
Toni Wahrstätter: Essentially, have a static check on the ball.

260
00:41:15.610 --> 00:41:30.169
Toni Wahrstätter: that, that isn't really a limiting factor at all, because, it allows to use the full block gas limit for anything, but it's just, a measure against a DOS attack by a malicious builder.

261
00:41:31.790 --> 00:41:41.279
Toni Wahrstätter: And the second item was how to invalidate BALS as early as possible, and regarding that, we discussed the blog post I had on Leaf Research two weeks ago.

262
00:41:41.670 --> 00:41:44.990
Toni Wahrstätter: which, essentially, said that

263
00:41:45.120 --> 00:41:55.410
Toni Wahrstätter: After executing transactions, we need to keep track of how many items in the ball have already been accessed, versus how many have not been accessed yet.

264
00:41:55.970 --> 00:42:02.529
Toni Wahrstätter: And then knowing how many have not been accessed yet, and knowing the gas remaining of the block.

265
00:42:02.880 --> 00:42:07.500
Toni Wahrstätter: One can also tell if this block is even realistic.

266
00:42:07.630 --> 00:42:09.640
Toni Wahrstätter: To be executed successfully.

267
00:42:10.650 --> 00:42:11.560
Toni Wahrstätter: And…

268
00:42:12.420 --> 00:42:25.929
Toni Wahrstätter: Those were the two optimizations. One of them, the strict cap would be a consensus rule, and the other would more be an implementation detail within clients to… as a measure against DOS attacks.

269
00:42:26.360 --> 00:42:31.210
Toni Wahrstätter: So, Mark, you already brought that topic up earlier. Do you wanna start?

270
00:42:32.860 --> 00:42:49.800
Marc: Yeah, I mean, just a quick question on what you said there. So, you're talking about, accesses, so do you think… I mean, I guess you could do it with both reads and writes, like this heuristic? At the moment, I just implemented it for the reads, but do you kind of see it being used across both?

271
00:42:50.870 --> 00:43:02.359
Toni Wahrstätter: So REITs is, of course, the safe way, because REITs are more expensive, so you would actually be overly strict in that regard, and if you kind of take the cheapest

272
00:43:02.760 --> 00:43:05.650
Toni Wahrstätter: Gas, that you can…

273
00:43:06.000 --> 00:43:13.580
Toni Wahrstätter: like, what is the cheapest? Of course, if there is a storage diff in the bul, you can assume that there was a write happening, basically.

274
00:43:13.830 --> 00:43:16.390
Toni Wahrstätter: For each storage, slot.

275
00:43:16.940 --> 00:43:24.839
Toni Wahrstätter: But this was just, to simplify it, to have it, calculated based on the reads. But you're basically proposing

276
00:43:25.000 --> 00:43:29.890
Toni Wahrstätter: To have the… the storage writes in the bulb be…

277
00:43:30.410 --> 00:43:34.149
Toni Wahrstätter: Priced higher with their actual gas consumption in that check.

278
00:43:35.720 --> 00:43:42.680
Marc: I wasn't really proposing it there, actually, I was just asking, asking which one you meant, just because, you said accesses, I wasn't too…

279
00:43:42.680 --> 00:43:44.890
Toni Wahrstätter: I see, okay. Okay.

280
00:43:44.910 --> 00:43:47.899
Marc: But yeah, but the thing actually… oh, sorry, go ahead.

281
00:43:48.500 --> 00:43:59.029
Toni Wahrstätter: No, no, just as you said, I wasn't really, going, thinking that much or that detailed. I was more thinking about how can this check be done as simple as possible.

282
00:43:59.480 --> 00:44:04.580
Toni Wahrstätter: With existing constants that we already use in the, in the specs.

283
00:44:05.260 --> 00:44:19.460
Marc: Okay, cool. Yeah, I see. But yeah, the main thing I wanted to raise is, I think, it doesn't account for, like, using the gas remaining, doesn't account for the few, system contracts that are executed at the end.

284
00:44:19.630 --> 00:44:29.529
Marc: which aren't using gas, so when I implemented it, like, it was getting some false positives because of that. So I had to change it to, like, exclude these,

285
00:44:29.640 --> 00:44:33.170
Marc: Like, post-execution, changes.

286
00:44:33.350 --> 00:44:35.850
Marc: But that's just, like, a small tweak, really.

287
00:44:36.200 --> 00:44:46.950
Toni Wahrstätter: Interesting. So you say we must… before… after counting the items in the barrel, we must filter out the items that originate from system contract calls.

288
00:44:48.000 --> 00:44:49.640
Marc: Yeah, so yeah, if you're comparing.

289
00:44:49.640 --> 00:44:50.539
Toni Wahrstätter: Yeah, that's a good point.

290
00:44:50.540 --> 00:45:04.520
Marc: If you're, like, gen… say you're, like, generating it, and you're, like, on the last transaction, so you can say there's zero gas left, but you can see there's still a few more, like, reads in the, like, to-go, so you're gonna reject it, but that's because those are actually paying

291
00:45:04.520 --> 00:45:12.109
Marc: no gas, right? So yeah, I think there's different ways you could fix it, but probably the simplest one is just to completely filter those out.

292
00:45:14.120 --> 00:45:22.640
Toni Wahrstätter: Right, yeah, I will… I will look into this. I think the items that are in the bowl because of system contract calls are…

293
00:45:23.130 --> 00:45:29.210
Toni Wahrstätter: Very limited anyway, so it's probably, like, the max number of items minus 10 or something.

294
00:45:29.870 --> 00:45:33.399
Toni Wahrstätter: But yeah, good point. This is definitely something we should do.

295
00:45:34.100 --> 00:45:47.549
Toni Wahrstätter: Because, of course, the goal here is to not be limiting at all, so the gas used, a gas limit would still be the only limiting factor here. This is just to allow us to statically detect an invalid block early on.

296
00:45:48.590 --> 00:46:04.669
Toni Wahrstätter: And yeah, without Mark's suggestion here, we would, actually be overly strict, even though it's just a few slots, but still, I will update the specs, PR, and also the PR against the EAP, because this is, like, the consensus change here.

297
00:46:07.480 --> 00:46:11.630
Toni Wahrstätter: Is there any other comment regarding those two approaches?

298
00:46:18.220 --> 00:46:28.369
Karim T. (matkt): I just wanted to ask a question. You are saying, doing… we should do this check periodically. I'm not sure to understand why we cannot do that for each transaction.

299
00:46:29.860 --> 00:46:32.050
Toni Wahrstätter: You could do it for each transaction, too, yeah.

300
00:46:32.160 --> 00:46:35.399
Toni Wahrstätter: I was just thinking, like, minimizing overhead.

301
00:46:35.550 --> 00:46:42.019
Toni Wahrstätter: So, you could do it, like, every 8 transactions, because if you have, like, 8 threads in theory, then…

302
00:46:42.200 --> 00:46:56.340
Toni Wahrstätter: 8 max size transaction would be parallelized, and only after the 8 transaction you actually get some meaningful result. This was my line of thought, but it might not make sense, so this is a client, implementation choice, I guess.

303
00:46:57.100 --> 00:46:57.720
Karim T. (matkt): Okay.

304
00:47:02.020 --> 00:47:06.040
Toni Wahrstätter: Yeah, just to clarify, one can do the check after each transaction.

305
00:47:06.150 --> 00:47:10.679
Toni Wahrstätter: It shouldn't matter. You would even, catch invalid blocks earlier.

306
00:47:18.800 --> 00:47:19.710
Toni Wahrstätter: Perfect.

307
00:47:21.300 --> 00:47:28.230
Toni Wahrstätter: Yeah, if there's nothing else, I would definitely then go on with, modifying the first,

308
00:47:28.610 --> 00:47:34.150
Toni Wahrstätter: two PRs to the specs and the EAP and make sure Mark's, input is incorporated.

309
00:47:34.580 --> 00:47:49.270
Toni Wahrstätter: regarding the second, check, remaining gas versus untouched items, this is just a line, I think it's in the security consideration or in the rational in the EAP, as this is not really something that

310
00:47:49.490 --> 00:47:50.590
Toni Wahrstätter: is specced.

311
00:47:52.530 --> 00:47:53.890
Toni Wahrstätter: Just as a heads up.

312
00:47:55.410 --> 00:47:59.879
Toni Wahrstätter: Before we move to our next topic, anything regarding invalid spells?

313
00:48:18.580 --> 00:48:29.290
Toni Wahrstätter: Just one more thing. We have a tool that allows you to modify the bul in the engine API, which we can later on use to actually test that on a testnet.

314
00:48:29.440 --> 00:48:33.619
Toni Wahrstätter: But I guess we don't need to test those things on a definite yet, so…

315
00:48:34.170 --> 00:48:39.479
Toni Wahrstätter: we can, we can delay that, invalid ball testing, I guess.

316
00:48:39.930 --> 00:48:41.830
Toni Wahrstätter: As in theory, it should just work.

317
00:48:42.050 --> 00:48:44.420
Toni Wahrstätter: We will then see on the testnet if it does.

318
00:48:46.950 --> 00:48:50.620
Toni Wahrstätter: Of course, we could test it earlier, but not sure if it's worth it.

319
00:48:53.430 --> 00:48:54.360
Toni Wahrstätter: Great.

320
00:48:56.540 --> 00:49:09.719
Toni Wahrstätter: Yeah, happy to have it, proud of the benchmarking efforts, too. Of course, this requires, like, passing a malicious bul to the EL. I'm not sure if we have the testing framework ready for that, but if it's possible, we should definitely do that.

321
00:49:10.990 --> 00:49:12.370
Toni Wahrstätter: If it's not too much work.

322
00:49:14.150 --> 00:49:24.439
jochem-brouwer: Yeah, I think it's just, yeah, go ahead. It's just adding, it's just passing it, like, as a new payload, right? So that should work directly, I would say.

323
00:49:25.010 --> 00:49:28.639
Toni Wahrstätter: Yeah, it's a malicious pedal, basically, where the ball is.

324
00:49:29.040 --> 00:49:34.080
Toni Wahrstätter: Different from what they pay. From the transaction, what they actually access.

325
00:49:37.280 --> 00:49:42.440
Toni Wahrstätter: Great, and then the last point I have on the agenda is regarding the JSON RPCs.

326
00:49:43.070 --> 00:49:59.200
Toni Wahrstätter: I wanted to get a quick check if clients have already implemented the JSON RPC methods for DEFNET2. I saw GAF did already, but I wasn't sure about the other clients, so if clients could give me a quick update if the

327
00:49:59.340 --> 00:50:01.820
Toni Wahrstätter: JSON RPC methods are actually implemented.

328
00:50:03.310 --> 00:50:05.410
Karim T. (matkt): Well, this is normally it's implemented, yeah.

329
00:50:11.230 --> 00:50:12.040
Toni Wahrstätter: Awesome.

330
00:50:13.830 --> 00:50:18.770
Toni Wahrstätter: Implemented for Peso, NetherMind, and GEF, I can see.

331
00:50:19.640 --> 00:50:21.439
Toni Wahrstätter: One thing…

332
00:50:21.640 --> 00:50:38.240
Toni Wahrstätter: I missed, and this is probably… this was my mistake here. So far, the JSON RPC specifications, how I did them by the time, was having the bytes, so basically the RLP text string in the…

333
00:50:38.660 --> 00:50:40.779
Toni Wahrstätter: response from the Chasener PC.

334
00:50:41.350 --> 00:50:47.920
Toni Wahrstätter: And recently, someone brought up that this should actually be the the object in JSON format.

335
00:50:49.560 --> 00:50:55.209
Toni Wahrstätter: So I'm wondering if this is something we can do until DevNet 3, basically taking the RLP

336
00:50:55.450 --> 00:51:00.720
Toni Wahrstätter: bytes and putting them into the objects when returning them on the JSRPC methods.

337
00:51:14.030 --> 00:51:15.250
Toni Wahrstätter: I saw…

338
00:51:15.710 --> 00:51:23.090
Toni Wahrstätter: GEF is right now returning the bytes as spec'd. I'm not sure if Beso does the same, but I would assume so, right?

339
00:51:25.830 --> 00:51:27.620
Karim T. (matkt): Yes, I think it's later.

340
00:51:29.380 --> 00:51:34.500
Karim T. (matkt): I should check, but normally it's okay. I don't know, Mirgi, if you are here? Can confirm?

341
00:51:37.130 --> 00:51:38.679
mirgee: Yeah, I think so.

342
00:51:39.800 --> 00:51:49.169
Karim T. (matkt): I just have a question regarding the naming. So, in Bezu, we have get block access list by block hash, but in the spec, I see get block access list by hash.

343
00:51:51.940 --> 00:52:00.139
Toni Wahrstätter: Yeah, so I think the difference here is that you say block hash versus…

344
00:52:00.400 --> 00:52:03.529
Toni Wahrstätter: block, right? That's the different… difference.

345
00:52:03.880 --> 00:52:04.830
Karim T. (matkt): So, for sure.

346
00:52:04.830 --> 00:52:05.600
Barnabas: Shh.

347
00:52:05.800 --> 00:52:06.620
Karim T. (matkt): Yes.

348
00:52:07.750 --> 00:52:11.219
Toni Wahrstätter: Okay, and it should be block hash, of course, yeah, that's true.

349
00:52:11.470 --> 00:52:12.670
Toni Wahrstätter: I will fix that.

350
00:52:15.140 --> 00:52:18.050
Barnabas: By number, or by block number?

351
00:52:20.250 --> 00:52:29.129
Toni Wahrstätter: By block number, I guess. I have to double-check that too, but since it's the block number, it should be block number, and there's no pile number.

352
00:52:31.900 --> 00:52:39.439
Toni Wahrstätter: Perfect, okay, I noted that down, I will… I will fix that in the JSON RPC specs, but then, essentially, for DEFNET3,

353
00:52:39.610 --> 00:52:46.590
Toni Wahrstätter: The to-dos would be to put the ball into the JSON object when returning it, And…

354
00:52:47.360 --> 00:52:50.929
Toni Wahrstätter: The JSON RPC naming will be by block number.

355
00:52:51.240 --> 00:52:53.059
Toni Wahrstätter: And by block hash.

356
00:52:53.530 --> 00:52:57.140
Toni Wahrstätter: Is that the correct summary of the three points?

357
00:52:58.460 --> 00:53:11.949
jochem-brouwer: I'm actually, yeah, just thinking about this, because if you would have the, you would normally have the block, header, and then you would likely request the,

358
00:53:12.070 --> 00:53:15.890
jochem-brouwer: the, the block XList hash by that.

359
00:53:16.230 --> 00:53:17.570
jochem-brouwer: I would say, because…

360
00:53:17.780 --> 00:53:23.110
jochem-brouwer: Are there situations where you already have the book access list hash, and you do not have the book header?

361
00:53:26.460 --> 00:53:31.940
Toni Wahrstätter: So usually the mapping is one-to-one, so there can only be one block access list per block.

362
00:53:32.290 --> 00:53:43.279
Toni Wahrstätter: And if you change the block hash, then the block access list would have to change too, so I think this should be fine, and… I would assume it's just the simplest to have it by block number and block hash.

363
00:53:43.410 --> 00:53:44.579
Toni Wahrstätter: I'm, of course.

364
00:53:44.790 --> 00:53:51.589
Toni Wahrstätter: open if clients want to change that to block, to block access list hash and block access…

365
00:53:52.270 --> 00:54:02.280
Toni Wahrstätter: Yeah, it would be block by block access list hash and by block number. So this is, like, not super clean, and it feels like doing both by block number and block hash feels cleaner.

366
00:54:03.800 --> 00:54:06.970
jochem-brouwer: Yeah, I, I think I, I think, I think I agree, yeah.

367
00:54:09.390 --> 00:54:26.990
jochem-brouwer: Yeah, I'm just… I'm just thinking, like, are there situations where there is a… where you have the block access as a hash, and you don't have the block, like, the block hash where this, exists? So someone just gives you this block access as a hash, and you just want to have the contents of this, because then you would want to request

368
00:54:27.080 --> 00:54:34.540
jochem-brouwer: If gets block access list, yeah, by hash, so meaning the block access list hash, not the block hash.

369
00:54:34.820 --> 00:54:37.050
jochem-brouwer: Then it was… Right, but…

370
00:54:37.050 --> 00:54:41.489
Toni Wahrstätter: But I see the only way that you get the hash is by getting the header, and then you have

371
00:54:41.830 --> 00:54:42.530
Toni Wahrstätter: cash, too.

372
00:54:43.080 --> 00:54:44.340
jochem-brouwer: That's right, yeah.

373
00:54:45.100 --> 00:54:48.379
jochem-brouwer: Yeah, okay, I would just think about it some more. We can do this async, yeah.

374
00:54:57.280 --> 00:55:00.900
Ameziane Hamlat: Just related to the… just related to the… Go ahead, yup.

375
00:55:01.030 --> 00:55:18.519
Ameziane Hamlat: Yeah, sorry. So we already have existing, LPC endpoints where we… when we have the block in the name, like the backtrace block, then we just follow either by hash or by number, because we already have the block.

376
00:55:18.890 --> 00:55:34.560
Ameziane Hamlat: So, for example, we have dibetrace block by hash, dibetrace block by number, ETH get block by number, and so on. Maybe we should respect the same investment, the same name.

377
00:55:40.960 --> 00:55:45.990
Toni Wahrstätter: Okay, I see. So you would say we… we should have

378
00:55:46.140 --> 00:55:55.380
Toni Wahrstätter: Get block access list by hash, and get block access list by number, instead of by block hash and by block number.

379
00:56:00.590 --> 00:56:09.080
Ameziane Hamlat: Actually, when you read it like that, it feels like block hash makes sense here. I am not sure anymore, because…

380
00:56:10.080 --> 00:56:16.389
Ameziane Hamlat: Because the… The block hash is the hash for the block.

381
00:56:17.150 --> 00:56:21.010
Ameziane Hamlat: Which is not the same as the block access list, right? Because we'.

382
00:56:21.010 --> 00:56:21.800
Toni Wahrstätter: Yeah, actually…

383
00:56:21.800 --> 00:56:22.440
Ameziane Hamlat: Yeah.

384
00:56:23.050 --> 00:56:25.130
Toni Wahrstätter: Yeah, I agree, I agree.

385
00:56:25.240 --> 00:56:38.699
Toni Wahrstätter: Maybe we should move that discussion, actually, as Barnaby proposes there, implicitly. Barnabas, like, move it into the RPC call, because this fee is, like, yeah, we should get it right, and I'm definitely…

386
00:56:38.980 --> 00:56:48.589
Toni Wahrstätter: Not the right person to decide on that exactly, so what is the right naming there? And probably we just want to follow the best practices here.

387
00:56:48.970 --> 00:56:51.600
Toni Wahrstätter: So, yeah, please chime in in the…

388
00:56:51.830 --> 00:56:55.339
Toni Wahrstätter: in the PR, I will post it into our chat here.

389
00:56:55.570 --> 00:56:56.870
Toni Wahrstätter: Into the agenda.

390
00:56:57.260 --> 00:56:59.620
Toni Wahrstätter: Not in the agenda, in the chat.

391
00:56:59.840 --> 00:57:04.600
Toni Wahrstätter: So please let me know what you think, and we can then figure that out there async.

392
00:57:14.940 --> 00:57:19.349
Toni Wahrstätter: Great. Anything else regarding that topic? Otherwise, we would move on.

393
00:57:20.370 --> 00:57:32.219
Toni Wahrstätter: maybe let's finish the call with some testing updates. I wanted to ask Rahul or Felipe if there… Stefan, is there anything else we should discuss this week regarding testing?

394
00:57:32.410 --> 00:57:36.260
Toni Wahrstätter: Especially if we're focused on DEFNET 2.

395
00:57:38.130 --> 00:57:47.890
Barnabas: Before we move on to testing, could I just pray that we would like to have it simulate RPC call implemented in the next Debnet as well?

396
00:57:48.250 --> 00:57:52.610
Barnabas: So it would be very good if, all the client devs look into that.

397
00:57:57.440 --> 00:58:03.250
Toni Wahrstätter: Okay, perfect. So that was eaves simulate, should be implemented in DefNet3, yeah.

398
00:58:06.160 --> 00:58:09.309
Toni Wahrstätter: Okay, yeah, please, clients, look into that.

399
00:58:12.020 --> 00:58:19.950
Toni Wahrstätter: And then… Is there any… is there any news regarding testing? Anything we should, pay attention to?

400
00:58:20.710 --> 00:58:23.640
raxhvl: There's, like, a new test that tests for…

401
00:58:23.870 --> 00:58:28.170
raxhvl: the EIP2935, for historical block hash.

402
00:58:28.820 --> 00:58:34.660
raxhvl: That's… that's in progress, so that's a new system contact that will be covered in the next release.

403
00:58:40.390 --> 00:58:41.690
Toni Wahrstätter: Perfect, thank you.

404
00:58:44.870 --> 00:58:48.419
felipe: Yeah, as far as more testing,

405
00:58:49.130 --> 00:58:58.190
felipe: I think, yeah, there's still a few tests, for bells that are coming out, just to extend, coverage, but,

406
00:58:59.180 --> 00:59:06.780
felipe: Maybe some of the things to address are the remaining failing tests that are already out from the last release.

407
00:59:06.940 --> 00:59:09.800
felipe: And some of these are related to only,

408
00:59:10.280 --> 00:59:16.380
felipe: The exception mismatch, and so there are invalid tests that are correctly invalid.

409
00:59:16.740 --> 00:59:24.159
felipe: But some clients have… are… are raising, the unexpected, exception there, and so…

410
00:59:24.470 --> 00:59:30.940
felipe: These should be fairly simple fixes. If clients can make them, yeah, that would be great. Otherwise…

411
00:59:31.420 --> 00:59:35.980
felipe: I will try to find some time to submit PRs for each of these clients.

412
00:59:36.390 --> 00:59:47.849
felipe: To at least get these invalid tests passing, but, we should look at the ones that are not related to this, and just have clients start getting all of these tests passing. Would be… would be priority.

413
00:59:48.500 --> 00:59:51.799
felipe: And then again, the benchmark tests

414
00:59:52.340 --> 00:59:58.769
felipe: are the next focus on the testing front, and we're making good, good progress here. And it seems like

415
00:59:58.900 --> 01:00:04.649
felipe: We may be, starting to use Geth for our benchmark releases, which is…

416
01:00:05.230 --> 01:00:17.550
felipe: If anyone has been involved in the benchmark testing at all, Geth is about 5 times faster in some cases than EVM1 was, which we were using for benchmarking, and so…

417
01:00:17.760 --> 01:00:20.859
felipe: This is gonna be a really nice, update there as well.

418
01:00:25.040 --> 01:00:27.409
Toni Wahrstätter: Awesome, thank you very much for the update.

419
01:00:31.320 --> 01:00:36.960
Toni Wahrstätter: Great. Before we end the call, is there anything else We should discuss today.

420
01:00:39.820 --> 01:00:49.740
jochem-brouwer: Yeah, I have, two more questions, sorry. The first is, did we already check?

421
01:00:49.890 --> 01:00:53.759
jochem-brouwer: the interactions with other Grand Slam proposed EIPs.

422
01:00:53.770 --> 01:01:00.880
jochem-brouwer: Because I could see interactions with the reduced intrinsic transaction guess. This will increase the amount of transactions per block.

423
01:01:00.890 --> 01:01:14.969
jochem-brouwer: This could theoretically also increase the max-sized book access list, and maybe also the repricings that could also impact this, in case that some prices are lowered.

424
01:01:15.660 --> 01:01:30.960
Toni Wahrstätter: Yeah, I think we are safe on that front, because the worst case is very clearly, coming from storage writes and storage reads, and both of those don't look like they would be… become cheaper when comes to them. So from a worst-case size, I think, things will…

425
01:01:31.290 --> 01:01:43.880
Toni Wahrstätter: only improve with the repricing EAPs being shipped. Regarding the other 4 EAPs that we already have on Defnet 2, it seems like there is no real issue with those and block of access list.

426
01:01:44.450 --> 01:01:50.550
Toni Wahrstätter: also looking at the other CFID OPs, I don't think there will be any surprises, at least,

427
01:01:51.110 --> 01:01:52.200
Toni Wahrstätter: what I saw.

428
01:01:53.000 --> 01:01:53.500
jochem-brouwer: Okay, cool.

429
01:01:53.500 --> 01:01:56.389
Toni Wahrstätter: Or have you… have you seen anything different?

430
01:01:56.700 --> 01:02:13.180
jochem-brouwer: No, no, no, I just want to check, yeah, I think we're safe, but I just wanted to raise the point. And my second question is about the def P2P, so EV71. So we are constrained there by also the 10 megabytes DevP2P limit.

431
01:02:13.380 --> 01:02:22.490
jochem-brouwer: And EVE70, introduced the partial receipts, so this actually allows the receipts, the… yeah.

432
01:02:22.660 --> 01:02:29.950
jochem-brouwer: all the bundles received should be more than 10 mega… 10 megabytes. I would also propose to also do this with the book access lists.

433
01:02:30.220 --> 01:02:37.710
jochem-brouwer: To allow this to have more than 10 megabytes, or, maybe this is not possible because of the already existing limits.

434
01:02:38.020 --> 01:02:45.690
jochem-brouwer: We just wanted to raise that in DevPTP, we have the 10 megabyte limit, and we should, figure out when this limit can be hit.

435
01:02:46.110 --> 01:02:55.279
jochem-brouwer: Or constrain this in the block, that it is not allowed to create a def… a block exist larger than some size.

436
01:02:57.960 --> 01:03:03.549
Toni Wahrstätter: Yeah, I agree. To me, it feels like the simplest approach would be to do the same for block cloud access lists that we do

437
01:03:03.670 --> 01:03:07.129
Toni Wahrstätter: for… for all the other objects in ETH70.

438
01:03:07.270 --> 01:03:08.680
Toni Wahrstätter: And then it should work.

439
01:03:10.580 --> 01:03:20.300
Toni Wahrstätter: So then we are basically, independent from the gas limit, the bulk level access list size can just grow linearly in theory, and we would still be fine.

440
01:03:21.930 --> 01:03:26.070
jochem-brouwer: Yeah, that sounds good. Okay, that was… that's my points, yeah.

441
01:03:27.390 --> 01:03:28.650
Toni Wahrstätter: Awesome, thanks.

442
01:03:29.540 --> 01:03:34.160
Toni Wahrstätter: Anything else we should discuss in today's call before we wrap up?

443
01:03:43.040 --> 01:03:43.870
Toni Wahrstätter: Right.

444
01:03:44.330 --> 01:03:47.109
Toni Wahrstätter: Yeah, that's all we had on the agenda today.

445
01:03:47.410 --> 01:03:51.359
Toni Wahrstätter: Next breakout call will take place in 2 weeks again.

446
01:03:52.840 --> 01:03:55.570
Toni Wahrstätter: Thanks a lot to everyone, and see you in two weeks.

447
01:03:57.450 --> 01:03:59.310
jochem-brouwer: Alright, thank you. Bye-bye.

448
01:03:59.590 --> 01:04:00.410
Jared Wasinger: I owe.

