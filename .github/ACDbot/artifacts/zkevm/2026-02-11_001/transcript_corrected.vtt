WEBVTT

1
00:00:11.790 --> 00:00:14.650
cody: And… Alright.

2
00:00:18.690 --> 00:00:21.670
cody: Seems like Mike is working.

3
00:00:23.060 --> 00:00:25.829
cody: What about the screen share?

4
00:01:15.720 --> 00:01:18.659
cody: Alright, using the mic testing feature…

5
00:01:26.810 --> 00:01:27.710
cody: Ouch.

6
00:01:39.950 --> 00:01:42.130
Kevaundray Wedderburn: Testing… Testing…

7
00:01:43.430 --> 00:01:44.259
cody: What's up?

8
00:01:48.920 --> 00:01:53.480
cody: I was on here testing. Let's see, I think you can see my screen, yeah?

9
00:01:53.790 --> 00:01:54.350
Kevaundray Wedderburn: Yo.

10
00:01:54.920 --> 00:01:56.020
cody: Great.

11
00:01:58.000 --> 00:02:03.340
Kevaundray Wedderburn: Okay, let me also test my screen share.

12
00:02:06.990 --> 00:02:08.650
Kevaundray Wedderburn: Can you see my screen?

13
00:02:09.410 --> 00:02:10.580
cody: Yes.

14
00:02:12.110 --> 00:02:13.919
Kevaundray Wedderburn: Is it, like, small?

15
00:02:15.390 --> 00:02:28.009
cody: I mean, you have that sort of box that's in the middle, it's, like, wide and flat. I don't know if that's a feature of your… your slides, or if it's, like, a feature of your screen, but I can see it in any case.

16
00:02:28.530 --> 00:02:30.379
Kevaundray Wedderburn: Oh yeah, it's meant to be white, and…

17
00:02:30.550 --> 00:02:33.859
Kevaundray Wedderburn: I can… yeah, I can zoom in to…

18
00:02:35.230 --> 00:02:37.739
cody: Yeah, that's… that's much more readable, that's good.

19
00:02:38.110 --> 00:02:38.900
Kevaundray Wedderburn: Okay.

20
00:02:40.010 --> 00:02:41.180
Kevaundray Wedderburn: Cool.

21
00:03:05.750 --> 00:03:07.050
Ladislaus: Hello, hello.

22
00:03:10.440 --> 00:03:11.430
cody: Hello.

23
00:03:12.060 --> 00:03:13.030
Ladislaus: Hi, Cody.

24
00:03:13.350 --> 00:03:14.649
Ladislaus: Good to see you.

25
00:03:15.870 --> 00:03:17.380
cody: Hello, from Boulder.

26
00:03:19.380 --> 00:03:21.580
cody: Participating, it's very nice.

27
00:03:21.710 --> 00:03:23.200
cody: What a beautiful place.

28
00:03:24.120 --> 00:03:24.650
Ladislaus: Nice.

29
00:03:25.440 --> 00:03:29.229
Ladislaus: Ready for… wait, is ETH Boulder already going?

30
00:03:29.900 --> 00:03:31.329
cody: It'll start Friday.

31
00:03:31.800 --> 00:03:32.550
Ladislaus: Nice.

32
00:03:33.070 --> 00:03:33.810
cody: Yeah.

33
00:03:47.460 --> 00:03:56.750
Ladislaus: Oh yeah, we got at least 30, 35 people signed up, so… Let's see

34
00:04:05.710 --> 00:04:06.780
Ladislaus: Hi, Jordy.

35
00:04:09.970 --> 00:04:11.200
Jordi - ZisK: Hello, Joria?

36
00:04:11.640 --> 00:04:13.739
Ladislaus: Welcome, welcome, good to see you.

37
00:04:20.500 --> 00:04:23.449
Ladislaus: Where's Kev? Is he here, or is it just his note-taker?

38
00:04:27.860 --> 00:04:32.559
cody: He's here, he was just testing his, audio and screen sharing.

39
00:04:32.690 --> 00:04:34.080
Ladislaus: Okay, okay.

40
00:04:35.020 --> 00:04:36.299
Ladislaus: Hi, Gary.

41
00:04:36.710 --> 00:04:37.930
Gary Schulte: Hello?

42
00:04:55.760 --> 00:04:56.730
Ladislaus: Hi, Farah.

43
00:05:00.640 --> 00:05:01.260
Fara Woolf: Hey.

44
00:05:05.940 --> 00:05:08.669
Ladislaus: Nice Guillaume, Stefan, good to see you.

45
00:05:09.210 --> 00:05:09.940
Kevaundray Wedderburn: Yay.

46
00:05:11.940 --> 00:05:12.600
Guillaume: Hey.

47
00:05:17.770 --> 00:05:20.679
Guillaume: Wow, Kevy's on camera, that's a big day.

48
00:05:32.690 --> 00:05:38.919
Kevaundray Wedderburn: Yeah, Gim, did you intentionally have the Stateless Summit on April the 1st, or was that just a coincidence?

49
00:05:39.600 --> 00:05:41.720
Guillaume: Yeah,

50
00:05:41.850 --> 00:05:49.240
Guillaume: Sort of. No, not for the joke, but, because it's the only day that didn't have that many,

51
00:05:49.420 --> 00:06:00.489
Guillaume: That made me alter interest. Well, okay. Sorry for those who actually organized something the same day, but it didn't seem like there was a big conflict in audiences.

52
00:06:02.220 --> 00:06:03.660
Kevaundray Wedderburn: Oh, I see, okay.

53
00:06:07.280 --> 00:06:08.629
Gary Schulte: But also the memes.

54
00:06:24.400 --> 00:06:29.910
Kevaundray Wedderburn: You know, we still seem to have people trickling in, so… give it about a minute.

55
00:06:35.630 --> 00:06:37.179
ignacio: Hello? Thanks, Jeremy.

56
00:06:38.060 --> 00:06:38.600
Kevaundray Wedderburn: Yep.

57
00:06:40.140 --> 00:06:41.529
Ladislaus: Yup, hi Ignacio.

58
00:07:12.250 --> 00:07:14.830
Kevaundray Wedderburn: Can folks see my screen clearly?

59
00:07:15.520 --> 00:07:16.590
Gary Schulte: Yep.

60
00:07:54.120 --> 00:07:55.230
Ladislaus: You're muted, Kef.

61
00:07:58.290 --> 00:08:00.660
Alex Hicks: Second.

62
00:08:00.660 --> 00:08:03.970
Kevaundray Wedderburn: Welcome to L1ZKVM, breakout tool number one.

63
00:08:04.110 --> 00:08:15.929
Kevaundray Wedderburn: For the newcomers, breakout calls are used in Ethereum to give a dedicated space to projects that are going to be shipped. Once the project is scheduled to be shipped in a hardcore…

64
00:08:15.930 --> 00:08:17.990
Justin Drake: to be recording, sorry to interrupt.

65
00:08:18.610 --> 00:08:20.430
Kevaundray Wedderburn: I believe we are recording.

66
00:08:20.650 --> 00:08:21.709
Justin Drake: Okay, perfect.

67
00:08:22.050 --> 00:08:35.450
Kevaundray Wedderburn: Oh, yeah, thank you. Yeah, so once the… once the project is scheduled to be shipped, during a hard fork, the breakout call then usually gets merged into the main governance call, which is known as All Core Devs.

68
00:08:36.370 --> 00:08:50.359
Kevaundray Wedderburn: So, the goal of this breakout call is to advance the roadmap that we set out earlier this year, that you all saw in the planning document. Let us know if you could put a link in the chat for people that want to look at it.

69
00:08:50.490 --> 00:09:04.290
Kevaundray Wedderburn: This call in particular will just be used to give an overview of the different work streams in the planning document, and we're going to give space for each person who's been working on each individual workstream, about 3 to 5 minutes to just explain, like, what's happening.

70
00:09:05.430 --> 00:09:18.989
Kevaundray Wedderburn: On shipping, we're aiming to have the work done by Glamsterdam, just because the main thing that's blocking is, ePBS, and we're aiming to also ship it, or propose it to be shipped in Hegota.

71
00:09:19.910 --> 00:09:23.620
Kevaundray Wedderburn: So, on that, I will start…

72
00:09:27.130 --> 00:09:43.419
Kevaundray Wedderburn: So, for logistics, we're aiming to have a monthly call on the second Wednesday of the month, 3pm UTC, all async discussions. Please put them inside of the ETH R&D channel. We have two, channels for this.

73
00:09:46.510 --> 00:09:53.409
Kevaundray Wedderburn: And on an announcement, the stateless team is hosting a Stateless Summit at EVCC.

74
00:09:53.850 --> 00:09:59.810
Kevaundray Wedderburn: On April the 1st, if you want to find out more details about this, just please scan the QR code.

75
00:10:03.310 --> 00:10:08.879
Kevaundray Wedderburn: So, just zooming out a bit, to explain the difference between mandatory and optional proofs.

76
00:10:09.100 --> 00:10:23.150
Kevaundray Wedderburn: So, with mandatory proofs, all the attesters are required, all the attesters require proofs in order to deem a block as valid. Re-execution by then will likely not be possible if you want to keep up with the chain.

77
00:10:23.210 --> 00:10:36.310
Kevaundray Wedderburn: this is a massive change to Ethereum, and so we're sort of doing it… we're sort of doing this intermediate step known as optional proofs, which front-loads a lot of the work and allows us to test it in a safer way.

78
00:10:36.750 --> 00:10:47.320
Kevaundray Wedderburn: With optional proofs, only some attesters need to… can opt into accepting proofs, but the majority of the attesters on the network will continue to re-execute as normal.

79
00:10:49.030 --> 00:10:59.870
Kevaundray Wedderburn: this breakout call, just to be explicit, will be for optional proofs. We may touch on some mandatory proof topics, but the main goal is for optional proofs.

80
00:11:02.470 --> 00:11:15.269
Kevaundray Wedderburn: Okay, so let's look at, sort of, what happened within a slot post-Glamsterdam, but pre-ZK, and we're using this to sort of motivate the workstream breakdown that we saw in the planning document.

81
00:11:18.600 --> 00:11:24.729
Kevaundray Wedderburn: I've split it into two phases. So, phase one involves the builder, proposer, and a tester.

82
00:11:25.090 --> 00:11:29.959
Kevaundray Wedderburn: The builder proposes an execution payload, which is a block, or EL block.

83
00:11:30.270 --> 00:11:40.509
Kevaundray Wedderburn: They then submit something known as a bid, and a bid commits to the execution payload, plus some value that the builder is putting on the execution payload.

84
00:11:41.110 --> 00:11:49.579
Kevaundray Wedderburn: the proposer for that, slot, then selects a bid. It can… because multiple builders will be publishing bids.

85
00:11:49.860 --> 00:11:54.219
Kevaundray Wedderburn: They produce a beacon block, And they submit this beacon block to the network.

86
00:11:54.600 --> 00:12:02.560
Kevaundray Wedderburn: The attesters then validate the beacon block, produce attestations, and submit these attestations to the network. So this is the first phase.

87
00:12:02.660 --> 00:12:11.300
Kevaundray Wedderburn: One minor note that might be interesting to folks who've never seen ePBS before is that once the attester validates the block.

88
00:12:11.450 --> 00:12:22.500
Kevaundray Wedderburn: the builder's balance is unconditionally reduced, so if he says that he's bidding 5 ETH, 5 ETH is unconditionally taken from the builder's balance.

89
00:12:26.760 --> 00:12:35.509
Kevaundray Wedderburn: The second phase, if you have seen ePBS, you can see that I've, like, massively simplified this part by removing the PTC, but the second phase

90
00:12:35.820 --> 00:12:48.610
Kevaundray Wedderburn: For our purposes, the builder then submits the execution payload to the network, the attesters then validate the execution payload, and for this, they obviously need an execution layer client.

91
00:12:49.860 --> 00:12:53.999
Kevaundray Wedderburn: I'll be taking questions at the end, by the way, I can't see the chat.

92
00:12:56.120 --> 00:13:04.620
Kevaundray Wedderburn: Okay, so what's the problem with this? The main problem is that the attester needs an execution layer client in order to validate the execution payload.

93
00:13:04.740 --> 00:13:17.370
Kevaundray Wedderburn: What this means is that as the gas limit increases, it's gonna take a lot longer to validate that the execution payload is correct, which means the attester's hardware requirements have to rise in order to do it in the same amount of time.

94
00:13:17.370 --> 00:13:26.980
Kevaundray Wedderburn: Which obviously leads to centralization pressure. Like, as you increase the hardware requirements and the bandwidth requirements, it becomes harder to be in a tester.

95
00:13:29.660 --> 00:13:33.919
Kevaundray Wedderburn: Okay, so how does… how do ZKVMs actually solve this issue?

96
00:13:36.560 --> 00:13:44.539
Kevaundray Wedderburn: Let's go back to Phase 1. Everything is the same, apart from this new object called an execution witness.

97
00:13:49.710 --> 00:13:54.709
Kevaundray Wedderburn: Phase 2 changes massively, And I'll give the caveat that

98
00:13:54.980 --> 00:14:14.920
Kevaundray Wedderburn: there are many design decisions that we can make here, like, if the builder is the prover, you can imagine there's just one box here. If the prover is now a known entity in the protocol, you can imagine the prover sort of sending to the attester directly. But with this current design, I'll explain how it goes. So the builder selects guest programs.

99
00:14:15.100 --> 00:14:17.439
Kevaundray Wedderburn: Ignacio will say what these are.

100
00:14:17.890 --> 00:14:27.330
Kevaundray Wedderburn: They then submit an execution witness that they produced in Phase 1, the execution payload, and the guest programs, to this new entity called approver.

101
00:14:27.820 --> 00:14:34.940
Kevaundray Wedderburn: The prover then creates proofs, based on the guest programs, execution witness, and the execution payloads.

102
00:14:35.420 --> 00:14:41.460
Kevaundray Wedderburn: he submits the ZK EVM proofs to the builder, and then the builder then forwards it to the attesters.

103
00:14:42.260 --> 00:14:53.460
Kevaundray Wedderburn: The attester then selects guest programs independently. If the guest programs that the attester selects and the guest programs that the builder selects are different, then the proof would not… will not verify.

104
00:14:53.850 --> 00:15:02.149
Kevaundray Wedderburn: So, the attester selects the guest programs, they then use the bid that they received from Phase 1, and verify all of the ZKVM proofs.

105
00:15:02.640 --> 00:15:09.620
Kevaundray Wedderburn: So, the guarantees that they get here are more cryptographical, but essentially, if they verify the ZKVM proofs, it's…

106
00:15:09.880 --> 00:15:14.190
Kevaundray Wedderburn: Roughly equivalent to them validating the execution payload by re-executing.

107
00:15:19.910 --> 00:15:20.690
Kevaundray Wedderburn: Okay.

108
00:15:21.890 --> 00:15:22.940
Kevaundray Wedderburn: So…

109
00:15:23.790 --> 00:15:32.699
Kevaundray Wedderburn: Now, these are the… if you've read the document, these are the 8, projects that we've split, or 8 work streams that we've split the work into.

110
00:15:32.810 --> 00:15:38.609
Kevaundray Wedderburn: The first is this execution witness object. We want to spec it out and optimize it.

111
00:15:39.100 --> 00:15:45.369
Kevaundray Wedderburn: So this is the, the first object that the builder produces in Phase 1 and submits to the prover.

112
00:15:45.760 --> 00:15:50.640
Kevaundray Wedderburn: The second is the guest program. That needs to be proven.

113
00:15:50.780 --> 00:15:59.819
Kevaundray Wedderburn: Deferred is this API boundary between the ZKVM and the guest program, and standardizing it, and Martin will talk a lot more about this.

114
00:16:00.450 --> 00:16:09.189
Kevaundray Wedderburn: The fourth is the consensus layer, so we need to make changes on the consensus layer in order to accept proofs and other sort of infrastructure changes.

115
00:16:09.940 --> 00:16:14.509
Kevaundray Wedderburn: The fifth is the prover infrastructure, so the actual software that's creating the proofs.

116
00:16:15.500 --> 00:16:34.109
Kevaundray Wedderburn: The 6 is benchmarking and metrics, so this is related to RTP, but also it's metrics and benchmarks for the consensus layer. Like, if we submit these proofs on the network, how long does it take for the 66% of the network to actually see these proofs, since they are quite big at the moment?

117
00:16:34.290 --> 00:16:39.150
Kevaundray Wedderburn: And the seventh is security, which Cody will go into more details about.

118
00:16:39.860 --> 00:17:01.540
Kevaundray Wedderburn: The eighth is, like, an external project, that we're not focusing on, which is ePBS. The reason is because we can't actually do this without ePBS. We need enough time to create these proofs. Currently in Fulu, which is what we've currently… which is what we currently have on Ethereum, it's about roughly 2 to 4 seconds, which is obviously not enough time.

119
00:17:03.510 --> 00:17:12.900
Kevaundray Wedderburn: Okay, so with that, I will start taking questions before we go to Ignacio, who will talk about the execution Witness and the ZKVM guest program.

120
00:17:18.839 --> 00:17:21.599
Kevaundray Wedderburn: I'll just check the chat.

121
00:17:26.900 --> 00:17:28.250
Kevaundray Wedderburn: Oh, thanks, bro.

122
00:17:30.500 --> 00:17:37.699
Kevaundray Wedderburn: Oh yeah, sorry, also Eve Bruce is at Eve CCC. Yeah, sorry, I didn't put it in my slides. There's a link in the description for…

123
00:17:37.880 --> 00:17:42.680
Kevaundray Wedderburn: for how you can register for Beast Merd.

124
00:17:43.190 --> 00:17:53.430
Kevaundray Wedderburn: Okay, so the first question is, what is the expected size of the ZKVM proofs? So currently, we're looking, the current,

125
00:17:54.740 --> 00:18:10.660
Kevaundray Wedderburn: The best case is it's 128 kilobytes. We're currently focusing on 300 kilobyte proofs, but I believe some ZKVMs are well above it, within the 600 kilobyte to 1MB size, though this is expected to go down.

126
00:18:14.340 --> 00:18:26.990
Kevaundray Wedderburn: Is there any incentive mechanisms for provers? So with optional proofs, because the majority of attesters won't be… won't need proofs, there is no incentives for optional

127
00:18:26.990 --> 00:18:43.890
Kevaundray Wedderburn: on the optional proof regime. With mandatory proofs, we're still going over, sort of, what the incentive mechanisms will be for provers, as in whether they should be in the protocol, or…

128
00:18:46.480 --> 00:18:46.940
Emiliano | Boundless: Still…

129
00:18:47.400 --> 00:18:50.060
Kevaundray Wedderburn: Amelie, I don't know, could you mute?

130
00:18:50.060 --> 00:18:50.790
Emiliano | Boundless: Sorry if…

131
00:18:53.160 --> 00:18:54.080
Kevaundray Wedderburn: Thank you.

132
00:18:55.550 --> 00:19:03.769
Kevaundray Wedderburn: Yeah, so the incentive mechanisms for provers, we're still going over. Julian is the one that's focusing on this, Julian Ma from RIG.

133
00:19:03.920 --> 00:19:09.620
Kevaundray Wedderburn: It really depends on how we think provers are going to be integrated into the protocol.

134
00:19:10.720 --> 00:19:22.799
Kevaundray Wedderburn: What do you expect the average proof verification time to be? Currently, so far, it's done a lot of measurements on this, and currently it's about 70 milliseconds to 100 milliseconds.

135
00:19:28.130 --> 00:19:31.100
Kevaundray Wedderburn: Okay, cool. Ignacio, do you want to get set up?

136
00:19:33.980 --> 00:19:34.980
ignacio: Yeah, sure.

137
00:19:35.470 --> 00:19:37.830
ignacio: Let me share my screen.

138
00:19:42.070 --> 00:19:43.350
ignacio: Can you see my screen?

139
00:19:46.280 --> 00:19:51.120
ignacio: Cool. I will go pretty fast, because we have much time, so sorry for that.

140
00:19:51.530 --> 00:19:59.009
ignacio: So, I will give a brief update, on project number one, which is this execution witness that we have mentioned before.

141
00:19:59.830 --> 00:20:15.430
ignacio: So, before giving any updates, let's go through a brief review about this is… what this is about. So here we have, like, the guest program that we are proving, and this guest program can be thought as a function.

142
00:20:16.020 --> 00:20:20.040
ignacio: So, all the information that is required should be received by parameters.

143
00:20:20.700 --> 00:20:27.440
ignacio: These parameters, are basically the new payload request, which is basically the execution payload.

144
00:20:28.300 --> 00:20:31.609
ignacio: Then we have this execution witness that we are focused on.

145
00:20:32.040 --> 00:20:34.230
ignacio: We have the chain configuration.

146
00:20:34.730 --> 00:20:44.189
ignacio: So, basically, the execution witness is all the information, apart from the blog, that the guest program needs to verify, the…

147
00:20:44.320 --> 00:20:45.850
ignacio: The block, right?

148
00:20:46.500 --> 00:20:53.930
ignacio: So, this execution witness basically, contains all the, state tree access states.

149
00:20:54.260 --> 00:20:59.639
ignacio: With, MPT proofs, because we cannot really trust this input.

150
00:20:59.840 --> 00:21:05.199
ignacio: So, for example, if a block contains a niche transfer, and it's low.

151
00:21:05.330 --> 00:21:09.650
ignacio: We need to provide NPK routes for the balance and the storage lock value.

152
00:21:10.500 --> 00:21:18.959
ignacio: Apart from that, we also need to provide the bike codes that were accessed in that blog, because bike codes are not part of the C3 today.

153
00:21:19.190 --> 00:21:24.320
ignacio: This is going to be changed whenever we do call junking, probably binary trees.

154
00:21:24.860 --> 00:21:32.290
ignacio: And we also need to provide, some set of ancestor headers, because we have EAP2935.

155
00:21:32.590 --> 00:21:35.900
ignacio: And also for Blue Cash upgrade solution.

156
00:21:36.710 --> 00:21:40.009
ignacio: So, the idea here is that,

157
00:21:40.200 --> 00:21:53.399
ignacio: we need… we want to standardize this execution witness and how is it generated, because ideally, we want any EL client to be able to generate this execution witness for a blog.

158
00:21:55.470 --> 00:22:06.789
ignacio: this should work in any other guest program. So, the situation that we want to avoid is only execution witnesses generated by guests.

159
00:22:07.310 --> 00:22:10.250
ignacio: are only usable by Agath, this program.

160
00:22:12.060 --> 00:22:25.089
ignacio: Because, ideally, if in production, for whatever reason, a specific EL has some bug or problem generating an execution witness, we want any other EL

161
00:22:25.410 --> 00:22:28.240
ignacio: Being able to generate a buddy's one.

162
00:22:28.450 --> 00:22:32.199
ignacio: That can use… can be used for any orgas program.

163
00:22:33.640 --> 00:22:47.160
ignacio: Also, this execution witness has many other, border cases that we should, properly test, so the only way to really create tests for this that all

164
00:22:47.360 --> 00:22:51.129
ignacio: guest program, can use is by having a standardized form.

165
00:22:52.280 --> 00:22:57.970
ignacio: So, here I have a really rough roadmap-ish of how we…

166
00:22:58.570 --> 00:23:06.690
ignacio: going to approach this at the spec level. I won't go into details, but I can share the slides later if you are interested.

167
00:23:07.810 --> 00:23:14.269
ignacio: So, the updates on this font are basically, Peter from the Steel team.

168
00:23:14.560 --> 00:23:17.810
ignacio: He's working on a generalized state tracker.

169
00:23:18.120 --> 00:23:25.980
ignacio: This state tracker is required for the execution witness, because whenever the block is executed, we need to track all the state that was accessed.

170
00:23:26.360 --> 00:23:32.549
ignacio: This type tracker was already created for Vals, so we are trying to reuse it and generalize it.

171
00:23:34.870 --> 00:23:45.399
ignacio: The state tracker used for balls do not really track the successor headers and byposts that I mentioned before, so I already created some PR on top of his work to extend it.

172
00:23:45.740 --> 00:23:52.169
ignacio: And I also did, like, a full end-to-end spec implementation of the Windows generation.

173
00:23:52.430 --> 00:23:59.620
ignacio: Mainly to identify all the blockers that we might have whenever we try to merge all these

174
00:23:59.720 --> 00:24:00.920
ignacio: In steps.

175
00:24:01.740 --> 00:24:09.240
ignacio: And finally, I wrote a quick document explaining, how OpenVM had another, kind of.

176
00:24:09.700 --> 00:24:17.059
ignacio: Way of expressing this execution witness that might be more optimal, that maybe we can use in the future in a later version.

177
00:24:19.800 --> 00:24:26.609
ignacio: Cool. Sis… The next project is project number two, and we'll move on with that.

178
00:24:28.020 --> 00:24:38.450
ignacio: So, this project number 3 is basically about, having a standardized test program in the stack that all the else can use as a reference to implement… to do their implementation.

179
00:24:39.100 --> 00:24:48.469
ignacio: In the previous project, I put this guest program as a kind of black box here, but we need… we really need to define what's going on here.

180
00:24:48.670 --> 00:24:55.989
ignacio: Because I think there might be some confusions that it's only, like, the state transition function, but we actually need to include more stuff here.

181
00:24:56.640 --> 00:25:01.639
ignacio: So, as a brief overview, you can think of the guest program in this way.

182
00:25:02.220 --> 00:25:08.770
ignacio: So here we have the state transition function that people already assumed it would be part of the logic.

183
00:25:08.950 --> 00:25:13.069
ignacio: But we also need to include, some other stuff, like…

184
00:25:13.400 --> 00:25:21.879
ignacio: the engine API, lawship and validations that today exist in ELs. This should be part of the best program.

185
00:25:22.390 --> 00:25:26.720
ignacio: Because the entity that will be consuming these proofs would be the CL.

186
00:25:27.080 --> 00:25:35.260
ignacio: and the CL today, like, API boundary for the… for the EL, is the engine API.

187
00:25:35.710 --> 00:25:44.030
ignacio: So, we have to include logic here, whenever we do login blobs, which is EIP8142,

188
00:25:44.160 --> 00:25:47.269
ignacio: We also need to do some extra work inside this program.

189
00:25:48.110 --> 00:25:54.279
ignacio: And we also, need to do some extra work regarding the, output commitments, that

190
00:25:54.530 --> 00:25:56.749
ignacio: That are needed for the verifier.

191
00:25:57.710 --> 00:26:09.519
ignacio: As part of the stage transition function, we need to do the execution witness validations. This is related to project number one, because, as mentioned before, the execution witness is not trusted data.

192
00:26:09.700 --> 00:26:20.770
ignacio: So, for example, all the NPT proofs that were provided should be validated, all the bycodes should be checked against the cold hash in the country's leaf nodes.

193
00:26:21.080 --> 00:26:23.279
ignacio: And the assessor has to be checked.

194
00:26:23.460 --> 00:26:27.720
ignacio: Using the, parent hash in the blockchain.

195
00:26:28.930 --> 00:26:43.650
ignacio: So, apart from defining this case program in the specs, which is the bulk of the work of this project, we also need to have reproducible steps to transform guest program source codes into the standardized targets.

196
00:26:44.270 --> 00:26:53.190
ignacio: This is not only, like, the compilation steps, but ideally having a way to,

197
00:26:53.800 --> 00:26:59.350
ignacio: reproduce exactly the same ELF binary that Yelp clients will publish.

198
00:26:59.760 --> 00:27:09.699
ignacio: Because this is directly linked with the verification key that will be used by CLS. So, ideally, we want anyone to reproduce this verification key.

199
00:27:09.890 --> 00:27:12.250
ignacio: from the guest program source code.

200
00:27:14.170 --> 00:27:28.300
ignacio: So, regarding the guest program, in the specs, Mario and Peter from the skill team are organizing a bit the steps that we have to do in the specs for this. There's a bunch of refactoring that should be done in

201
00:27:28.640 --> 00:27:31.320
ignacio: Today, because the way that the specs were

202
00:27:31.890 --> 00:27:37.719
ignacio: assume that the EL client is stable, or has a database.

203
00:27:37.910 --> 00:27:45.139
ignacio: So, this should be generalized such that any state access can be set by a database, or by your execution witness, or something specific.

204
00:27:45.490 --> 00:27:48.140
ignacio: So there are some steps to be done there.

205
00:27:48.480 --> 00:27:54.120
ignacio: Then there were some progress by developer Uche regarding,

206
00:27:54.620 --> 00:27:59.490
ignacio: Gaining more confidence that the current guest programs that we,

207
00:27:59.750 --> 00:28:03.550
ignacio: How today are reproducible in the population?

208
00:28:03.870 --> 00:28:11.480
ignacio: And also include some, signature inclusion, because this will be part of the distribution, process.

209
00:28:11.630 --> 00:28:12.689
ignacio: In the future.

210
00:28:13.840 --> 00:28:22.670
ignacio: And regarding client updates, Ivan from YouthRex have also, made progress on the health distribution pipeline.

211
00:28:23.070 --> 00:28:30.440
ignacio: And they have been doing also some guest program refactors. All these things are links that you can click on them, and…

212
00:28:30.700 --> 00:28:33.309
ignacio: Whenever I share the slides in the chat.

213
00:28:33.840 --> 00:28:41.379
ignacio: And finally, I implemented this EIP825 for ethics and REST, mainly because

214
00:28:41.840 --> 00:28:45.190
ignacio: all these, engine API stuff.

215
00:28:45.820 --> 00:28:59.440
ignacio: required for the checks, is done in Rust, and both clients are in Rust, so there's kind of some synergy there. This is a pretty big VIP, to implement.

216
00:29:01.930 --> 00:29:08.320
ignacio: But I left some comments in the PR that maybe all the other clients might want to look at,

217
00:29:09.470 --> 00:29:17.149
ignacio: So yeah, that's the end of project number two. I will come back again whenever I share progress about project number 6.

218
00:29:23.760 --> 00:29:26.709
Kevaundray Wedderburn: Any questions for Ignacio?

219
00:29:41.390 --> 00:29:46.009
Kevaundray Wedderburn: And while that's happening, Marcin, if you could, start sharing your screen.

220
00:29:46.760 --> 00:29:48.970
Kevaundray Wedderburn: For project number 3…

221
00:29:55.700 --> 00:29:57.670
Marcin Bugaj: Okay, can you hear me?

222
00:30:01.040 --> 00:30:04.589
Marcin Bugaj: So, hi everyone. Today, I'll share

223
00:30:04.960 --> 00:30:13.670
Marcin Bugaj: two threads of work that I've been focusing on. The main one is ZKVM interface standards. We just released version 0.

224
00:30:13.960 --> 00:30:20.600
Marcin Bugaj: This is about creating a common foundation for how ZKVMs integrate with execution clients.

225
00:30:21.180 --> 00:30:24.600
Marcin Bugaj: The second smaller project is exploring whether

226
00:30:24.700 --> 00:30:31.640
Marcin Bugaj: We can enable languages like Go and C Sharp to compile to bare-metal ZKVM targets via WebAssembly.

227
00:30:34.610 --> 00:30:41.619
Marcin Bugaj: So let me paint the picture of what execution client teams were facing before we created those standards.

228
00:30:41.930 --> 00:30:53.880
Marcin Bugaj: Imagine your execution client team preparing for ZKVM-based proving. You look at the landscape and see multiple VMs, SP1, ZISK, RISC-0, OpenVM, and so on.

229
00:30:54.250 --> 00:31:03.080
Marcin Bugaj: Each one requires custom compilation targets, each has different pre-compiled interfaces, Each handles I.O. differently.

230
00:31:03.310 --> 00:31:11.739
Marcin Bugaj: This means if you want to support 3 ZKVMs, you're potentially looking at 3 completely separate integrations.

231
00:31:12.000 --> 00:31:16.110
Marcin Bugaj: That's a lot of duplicated work and maintenance burden.

232
00:31:16.830 --> 00:31:20.080
Marcin Bugaj: So, to address these fragmentation.

233
00:31:20.210 --> 00:31:26.189
Marcin Bugaj: We've created 3 initial standards in collaboration with multiple ZKVM teams.

234
00:31:26.440 --> 00:31:39.049
Marcin Bugaj: The first standard standardizes… the first standard standardizes the RISC-V target triple for ZKVMs being used on Ethereum. The second introduces a C interface for precompiles.

235
00:31:39.430 --> 00:31:44.589
Marcin Bugaj: And the third is a C interface for doing input and output.

236
00:31:46.320 --> 00:31:50.879
Marcin Bugaj: Let me dive a bit deeper Into the first standard.

237
00:31:51.090 --> 00:31:59.829
Marcin Bugaj: So, RV64IM is the 64-bit RISC-V instruction set with integer multiplication

238
00:32:00.080 --> 00:32:05.649
Marcin Bugaj: And division, and that will be a baseline, for our architecture.

239
00:32:05.830 --> 00:32:16.719
Marcin Bugaj: On top of that, there is a requirement for, unaligned access extension, and that's interesting.

240
00:32:17.970 --> 00:32:21.369
Marcin Bugaj: Now, you may ask why we care about misaligned accesses.

241
00:32:21.670 --> 00:32:29.339
Marcin Bugaj: And it's a pragmatic safety net. So if a compiler mistakenly produces misaligned accesses.

242
00:32:29.440 --> 00:32:31.349
Marcin Bugaj: Execution remains correct.

243
00:32:31.600 --> 00:32:34.440
Marcin Bugaj: Possibly just slower with that extension.

244
00:32:34.670 --> 00:32:38.590
Marcin Bugaj: This prevents subtle toolchain differences from being…

245
00:32:38.900 --> 00:32:42.630
Marcin Bugaj: Becoming consensus and liveness issues.

246
00:32:45.570 --> 00:33:03.390
Marcin Bugaj: The second standard addresses the issue of calling precompiles. Ethereum's EVM has precompiles which are expensive to prove using standard RISC-V instructions, so ZKVMs implement them as optimized ZKVM-specific circuits.

247
00:33:03.930 --> 00:33:09.019
Marcin Bugaj: Without the standard, HCKVM has a different way of calling those precompiles.

248
00:33:09.530 --> 00:33:18.530
Marcin Bugaj: Our C-based API solves this problem. Execution client teams can write their pre-compiled calling code once.

249
00:33:19.050 --> 00:33:25.090
Marcin Bugaj: And then switch between CKVM backends without invasive refactors.

250
00:33:26.380 --> 00:33:33.080
Marcin Bugaj: The third standard is about I.O, how guest programs communicate with the outside world.

251
00:33:33.420 --> 00:33:38.140
Marcin Bugaj: They need to receive private input data from the host.

252
00:33:38.510 --> 00:33:42.700
Marcin Bugaj: And also commit to public outputs that verifier can check.

253
00:33:43.190 --> 00:33:48.600
Marcin Bugaj: The C-based API provides two simple functions for this task.

254
00:33:48.900 --> 00:33:55.090
Marcin Bugaj: Those functions are tailored for ZKVM needs and optimized for performance.

255
00:33:57.730 --> 00:34:12.180
Marcin Bugaj: Now let me switch to the second work thread, which is about expanding language support. Right now, if you want to write code that runs in the ZKVM, you're basically limited to Rust and C++.

256
00:34:12.449 --> 00:34:16.159
Marcin Bugaj: Languages that can compile directly to bare-metal RISC-V.

257
00:34:16.440 --> 00:34:22.170
Marcin Bugaj: But what about Go and C Sharp? These languages are also used by client implementations.

258
00:34:22.840 --> 00:34:29.929
Marcin Bugaj: We're exploring one possible way of bringing these languages to bare metal platform.

259
00:34:30.040 --> 00:34:34.570
Marcin Bugaj: We compiled those high-level languages to WebAssembly first.

260
00:34:34.850 --> 00:34:39.610
Marcin Bugaj: Then compile that WebAssembly files into RISC-V bare metal.

261
00:34:39.820 --> 00:34:45.779
Marcin Bugaj: The question is whether the performance penalty of that intermediate step is acceptable.

262
00:34:46.170 --> 00:34:53.309
Marcin Bugaj: Initial benchmarks of the WASM approach for the state transition function in Go.

263
00:34:53.420 --> 00:34:57.029
Marcin Bugaj: Shows about 3 times instruction count overhead.

264
00:34:57.170 --> 00:34:59.710
Marcin Bugaj: Compared to direct compilation.

265
00:35:01.350 --> 00:35:13.319
Marcin Bugaj: But here's the thing. Instruction count doesn't tell the full story when you're talking about ZKVMs. Normal RISC-V instructions have different proving costs than precompiles.

266
00:35:13.650 --> 00:35:19.350
Marcin Bugaj: So, the next steps are to integrate those precompiled accelerators.

267
00:35:19.630 --> 00:35:23.470
Marcin Bugaj: And measure actual proving time, not just instruction count.

268
00:35:23.790 --> 00:35:26.510
Marcin Bugaj: To find out more about,

269
00:35:27.000 --> 00:35:31.130
Marcin Bugaj: Was an approach for compilation of high-level languages.

270
00:35:33.590 --> 00:35:46.229
Marcin Bugaj: Let me wrap up with a bigger picture. So, the three standards reduce integration complexity for execution client and enable fair comparisons between different ZKVM implementations.

271
00:35:46.640 --> 00:35:54.570
Marcin Bugaj: And the language expansion work, if successful, could open up alternative ways of compiling high-level languages.

272
00:35:54.680 --> 00:35:57.999
Marcin Bugaj: Which is good for diversity and resilience.

273
00:35:59.650 --> 00:36:08.069
Marcin Bugaj: All of this work is open source, in the ZKVN standards repository and WAS Risk Repository on GitHub.

274
00:36:08.540 --> 00:36:14.649
Marcin Bugaj: Please review the standards if you haven't yet, and share your perspective. Thanks.

275
00:36:19.850 --> 00:36:23.399
Kevaundray Wedderburn: I can read out any questions, if there are any in the chat.

276
00:36:33.930 --> 00:36:51.999
Kevaundray Wedderburn: None. I think one point to make here is that, I don't know if Leo is on the call, but they've been working a lot with WASM as well, in particular Warm Air, so we might see some stuff that integrates well with that. It's a bit different since we're compiling Wasm to RISC, but…

277
00:36:52.000 --> 00:36:59.390
Kevaundray Wedderburn: Possibly you can go from WASM just proving the WASM directly, or proving… converting the WASM to Wamir, and then proving that…

278
00:37:01.640 --> 00:37:04.649
Kevaundray Wedderburn: Okay, there's no… okay, Guillaume?

279
00:37:05.270 --> 00:37:23.170
Guillaume: Yeah, it's a side question, based on what you just, like, you just mentioned Powder. Powder wants to have automated precompiles. Do we… how does the C interface project, you know, takes that into account, like.

280
00:37:23.180 --> 00:37:35.570
Guillaume: I know for our WASM project, we would like to use the automated precompiles from Powder, at least see how good it is. Yeah, it seems to be at odd with that other project of having

281
00:37:35.660 --> 00:37:37.680
Guillaume: Yeah.

282
00:37:38.150 --> 00:37:43.140
Guillaume: like, C headers for the precompile, so I'm just wondering, how do we reconcile that?

283
00:37:44.940 --> 00:37:45.600
Kevaundray Wedderburn: Right.

284
00:37:45.650 --> 00:37:46.420
Marcin Bugaj: Oh.

285
00:37:47.280 --> 00:37:55.789
Marcin Bugaj: Yeah, so the idea is that each ZKVM vendor will have to implement that C interface that is standardized.

286
00:37:55.950 --> 00:38:12.280
Marcin Bugaj: And the application logic won't have to change, so basically, the implementation of precompiles will be provided by ZKM vendors, and that will be resolved at the linking stage of the program, so…

287
00:38:12.390 --> 00:38:20.610
Marcin Bugaj: The program will have to be recompiled, with the correct, with the correct,

288
00:38:20.780 --> 00:38:40.720
Marcin Bugaj: archive for pre-compile implementation, as well as for the implementation for I.O. But the logic itself, whether it's in Rust or C or C++, or other language that can bind to C,

289
00:38:40.800 --> 00:38:44.510
Marcin Bugaj: The logic won't have to be refactored or changed.

290
00:38:44.730 --> 00:38:53.860
Marcin Bugaj: So that's the idea. So, so basically, the idea is that, the implementation of,

291
00:38:54.560 --> 00:38:59.740
Marcin Bugaj: the CE interface is provided by ZKVM vendors.

292
00:39:02.750 --> 00:39:20.039
Kevaundray Wedderburn: Maybe some context, we have about 2 minutes remaining for this section, but maybe some context on this precompile notion, what Guillaume was talking about, is that currently ZKVMs essentially provide an API for accelerating certain algorithms.

293
00:39:20.040 --> 00:39:23.990
Kevaundray Wedderburn: So, like, CatTrack or, ACDSA,

294
00:39:24.090 --> 00:39:41.009
Kevaundray Wedderburn: And there's a C interface that we've standardized on that allows the guest program to access these, but these are sort of fixed precompiles, and they're fixed circuits in the ZKVMs, while auto-precompiles can be seen as sort of an automatic way, where they

295
00:39:41.010 --> 00:39:44.999
Kevaundray Wedderburn: check. They look at the guest program, and then they figure out, okay, what…

296
00:39:45.720 --> 00:39:52.820
Kevaundray Wedderburn: What can we do here to speed it up based on this particular guest program, instead of having these generic precompiles?

297
00:39:53.170 --> 00:40:05.240
Kevaundray Wedderburn: I… I think it might require a bit more investigation, but my feeling is that we might not need the C headers for the precompiles if this is the case. Leo, do you want to opine on this?

298
00:40:06.300 --> 00:40:09.730
Leo Alt [powdr]: Yeah, I think just the… Hmm…

299
00:40:10.630 --> 00:40:16.729
Leo Alt [powdr]: In the Auto Brick and Pulse case, what you can do is basically the guest can just choose not to use

300
00:40:17.040 --> 00:40:20.650
Leo Alt [powdr]: Like, this interface or any brick-and-file interface from…

301
00:40:20.830 --> 00:40:24.309
Leo Alt [powdr]: ZKVMs, or choose a specific subset, for example.

302
00:40:24.430 --> 00:40:31.720
Leo Alt [powdr]: that autopre compiles may be performing badly, for instance, and then, so you can choose which ones you want, you can choose none, or you can choose all.

303
00:40:31.930 --> 00:40:34.269
Leo Alt [powdr]: So I think this would be the easiest for a guest.

304
00:40:34.620 --> 00:40:39.610
Leo Alt [powdr]: that wants to use Auto Recompiles to just basically then just not use…

305
00:40:39.980 --> 00:40:43.709
Leo Alt [powdr]: The precompiles that might be working well already with other precompiles.

306
00:40:45.690 --> 00:40:54.299
Kevaundray Wedderburn: Okay, cool. Yeah, just to keep, with time, maybe we can discuss this on Discord as well.

307
00:40:55.500 --> 00:40:59.170
Kevaundray Wedderburn: Tao, do you mind, sharing your screen?

308
00:41:10.810 --> 00:41:11.940
Francesco Risitano: Can you guys hear me?

309
00:41:13.000 --> 00:41:13.760
Kevaundray Wedderburn: Yep.

310
00:41:14.790 --> 00:41:20.860
Francesco Risitano: Cool. So yeah, I've been working on the consensus layer integration, and…

311
00:41:21.560 --> 00:41:27.879
Francesco Risitano: in this talk, I'm gonna essentially give an update on the, on the specs,

312
00:41:28.170 --> 00:41:33.330
Francesco Risitano: And finally, the progress on the Lighthouse, the Lighthouse implementation.

313
00:41:33.430 --> 00:41:47.020
Francesco Risitano: So, to start off, just want to give a quick refresher on the Engine API. So the Engine API is essentially the API that the consensus layer uses to interact with the execution layer.

314
00:41:47.040 --> 00:42:03.740
Francesco Risitano: And the new payload request is essentially the data payload which is used, in the request. So, when the consensus layer receives a new beacon block, it constructs this object, the new payload request, which contains the execution payload.

315
00:42:03.740 --> 00:42:09.699
Francesco Risitano: The versioned hashes, the beacon block, parent beacon block, and execution requests.

316
00:42:10.160 --> 00:42:18.189
Francesco Risitano: And essentially, it asks the execution layer, or the execution engine, to verify that it's correct.

317
00:42:18.210 --> 00:42:34.420
Francesco Risitano: And, some of these methods require the full execution payload, so that includes the transaction data. So the main takeaway from this slide is, currently the, yeah, the execution layer requires full transaction

318
00:42:34.430 --> 00:42:40.079
Francesco Risitano: Data to kind of verify the new payload request and to assert that the new payload is valid.

319
00:42:40.440 --> 00:42:50.650
Francesco Risitano: So ideally in the future, we want to, kind of remove the requirement for ZCAS testers in which they would need the transaction data.

320
00:42:50.860 --> 00:42:58.329
Francesco Risitano: So the idea is, essentially we move this to the, kind of, we move the abstraction,

321
00:42:58.530 --> 00:43:06.679
Francesco Risitano: For the prover, from kind of just the execution of the block to this, to verifying the whole new payload request.

322
00:43:06.860 --> 00:43:20.519
Francesco Risitano: So, essentially, it's the same checks, but it outputs the new payload request root. So that is essentially just the hashtree root of the new payload request.

323
00:43:20.560 --> 00:43:35.939
Francesco Risitano: And inside of the proofs, we do… inside of the prover, we do all of these, kind of consistency checks to assert that the, the versioned hashes, so the KZG commitments for the blobs, and the execution requests are consistent with the transaction data.

324
00:43:36.900 --> 00:43:46.190
Francesco Risitano: And then, in regards to verifying the proof, the public input moves to this new payload request route.

325
00:43:46.800 --> 00:43:59.309
Francesco Risitano: So, so… so… let me move to the next slide. So here we can see the relationship between the, the data types, which we have in the,

326
00:43:59.550 --> 00:44:12.330
Francesco Risitano: in the consensus specs for optional proofs, so there's a direct mapping between the new payload request and the new payload request header. What's nice about this is they ultimately hash to the same root.

327
00:44:12.510 --> 00:44:21.349
Francesco Risitano: So you can replace the execution payload with the execution payload header, still construct the, the same public input.

328
00:44:22.810 --> 00:44:31.880
Francesco Risitano: So, yeah, ultimately that kind of just provides a bit of context on the… on the guest program modifications that Ignacio, touched on.

329
00:44:32.230 --> 00:44:43.029
Francesco Risitano: And then, in regards to the signed execution proof, this is the proof, type that is gossiped over the network. We have the actual execution proof.

330
00:44:43.130 --> 00:45:00.670
Francesco Risitano: We have the validator index, so just to provide context, we're gonna use signed proofs, because, if we had unsigned proofs, then people could just send around a bunch of invalid proofs. They take 100 milliseconds to verify, and, you know, you can just grief the network.

331
00:45:00.670 --> 00:45:07.240
Francesco Risitano: So, yeah, the idea is essentially to use the validator set to sign these proofs,

332
00:45:07.500 --> 00:45:15.899
Francesco Risitano: And the, the execution proof contains the proof data, the proof type, and the public input, which is this new payload request root.

333
00:45:18.230 --> 00:45:27.249
Francesco Risitano: So, we introduced the proof engine, which is essentially kind of analogous to the execution engine, but instead of working with,

334
00:45:27.310 --> 00:45:46.239
Francesco Risitano: kind of the new payload request, or the full execution payload, it works with the new payload request header and the, the execution payload header. So we have, verify execution proof method, we have new payload, notify new payload header method, and, request proofs method.

335
00:45:47.720 --> 00:45:52.349
Francesco Risitano: So, yeah, I'm gonna run through a few flows,

336
00:45:53.610 --> 00:46:02.130
Francesco Risitano: And to kind of show how the proof engine integrates. So, we receive a new beacon block, we extract the new payload request header.

337
00:46:02.250 --> 00:46:08.280
Francesco Risitano: We then, invoke this method on the proof engine. So we send a new payload request header.

338
00:46:08.410 --> 00:46:11.840
Francesco Risitano: The proof engine caches the header.

339
00:46:12.070 --> 00:46:20.560
Francesco Risitano: Such that in the future, when it receives proofs, it can kind of, you know, correspond them with this new payload request header.

340
00:46:20.870 --> 00:46:29.660
Francesco Risitano: And then it returns syncing, and the beacon node will import the, the beacon block optimistically into the fork choice store.

341
00:46:30.790 --> 00:46:49.580
Francesco Risitano: Then when we receive, execution proofs, we receive them over P2P, we look up the validator index, which was included in the signed execution proof, we verify that the signature, is correct, according to, the proof message, which is the execution.

342
00:46:49.710 --> 00:46:57.529
Francesco Risitano: yeah, which is the execution proof itself, essentially just a hash of the execution proof. And then, if that's successful.

343
00:46:57.850 --> 00:47:03.329
Francesco Risitano: We, invoke the verify execution proof method on the proof engine.

344
00:47:03.690 --> 00:47:10.270
Francesco Risitano: We, we check if there's sufficient proofs, so we've got a K of N requirement.

345
00:47:10.370 --> 00:47:29.639
Francesco Risitano: And if so, we communicate valid back to the beacon node, and the beacon node will mark the block as valid in the fork choice store. So previously it was marked as kind of optimistic, but now it can mark it as valid and say that, you know, this block is ready to be, attested by the validator.

346
00:47:29.920 --> 00:47:33.920
Francesco Risitano: And then finally, we rebroadcast the proof.

347
00:47:37.340 --> 00:47:43.130
Francesco Risitano: And then in regards to proof generation, so the idea is that

348
00:47:43.180 --> 00:47:59.900
Francesco Risitano: You know, for optional proofs, we don't have this requirement in which the builder has to generate the proofs, so in the interim, we'll use, validators to fulfill this responsibility, or some, you know, it's opt-in, essentially, this role. It's not required.

349
00:48:00.560 --> 00:48:05.950
Francesco Risitano: But they'll observe a new beacon block, they'll extract a new payload request.

350
00:48:06.140 --> 00:48:23.500
Francesco Risitano: They will then invoke this request proofs method on the proof engine, specifying, the new payload request which needs to be proved, and, proof attributes, which is essentially the different proof types, so, the different, yeah, provers that need to be invoked.

351
00:48:23.550 --> 00:48:27.319
Francesco Risitano: it will receive a proof generation ID, and then,

352
00:48:27.370 --> 00:48:42.550
Francesco Risitano: The proof generation happens asynchronously, and they are sent back from the proof engine to the validator who signs them and subsequently gossips them on the execution proof topic on the beacon node.

353
00:48:43.790 --> 00:48:51.800
Francesco Risitano: So, in regards to the proof gossip protocol, we had, two requirements in which we don't want there to be

354
00:48:52.100 --> 00:48:53.170
Francesco Risitano: a fork.

355
00:48:54.890 --> 00:49:09.850
Francesco Risitano: well, yeah, we don't want there to be a… well, that's the primary, constraint, essentially. We don't want there to be a fork, and, also we can't slash for invalid proofs. So, yeah, this is kind of the construction we,

356
00:49:10.110 --> 00:49:22.819
Francesco Risitano: we decided on. I should note that these specs may change, they're not kind of firm. But yeah, essentially the validator signs the proof and then broadcasts the proof on the execution proof topic.

357
00:49:22.910 --> 00:49:41.039
Francesco Risitano: Nodes will ban peers if they… if the peer has sent them an invalid proof, and they will ban, validators, so essentially, if they ever receive a new proof signed by a validator which previously sent them an invalid proof, they will not even try to verify it.

358
00:49:41.520 --> 00:49:51.199
Francesco Risitano: And one of the problems with that is consensus, because a validator could send a valid proof to validator C, and an invalid proof to validator B.

359
00:49:51.500 --> 00:50:07.250
Francesco Risitano: And, yeah, validator B would, reject the proof, validator C would accept it. So the idea is that, validators will re-sign the proof with their own, with their own validator key, essentially. So then we kind of…

360
00:50:07.250 --> 00:50:07.570
Kevaundray Wedderburn: bad.

361
00:50:07.570 --> 00:50:09.549
Francesco Risitano: Move to a… sorry.

362
00:50:09.800 --> 00:50:14.590
Kevaundray Wedderburn: Sorry, just, putting the timer up that we have one minute, just in case.

363
00:50:15.390 --> 00:50:16.920
Francesco Risitano: Yeah, I'm nearly done.

364
00:50:17.080 --> 00:50:30.870
Francesco Risitano: So, yeah, that's the general idea. It's re-signed and sent to validator B, and then the assumption is just 1 of N, so you have one, validator who… one honest validator that re-signs and propagates the proof.

365
00:50:31.290 --> 00:50:34.350
Francesco Risitano: Yeah, and in terms of the Lighthouse implementation.

366
00:50:34.620 --> 00:50:37.799
Francesco Risitano: We've implemented the proof engine,

367
00:50:38.080 --> 00:50:45.100
Francesco Risitano: the proof gossip is implemented. We've done the, kind of, signature verification stuff.

368
00:50:45.250 --> 00:50:52.730
Francesco Risitano: we've introduced a new service on the validator for, kind of, doing the signing and requesting of proofs.

369
00:50:53.020 --> 00:51:01.739
Francesco Risitano: done the integration between the beacon chain and the proof engine, and unit tests have implemented… been implemented. And then we have a few more

370
00:51:01.890 --> 00:51:06.970
Francesco Risitano: Bits of work to do, but yeah, made some decent progress there.

371
00:51:07.390 --> 00:51:08.900
Francesco Risitano: Yeah, that's all.

372
00:51:13.620 --> 00:51:16.349
Kevaundray Wedderburn: Are there any questions for Tao?

373
00:51:23.160 --> 00:51:26.950
Kevaundray Wedderburn: Manu, if you want to start sharing your screen…

374
00:51:29.460 --> 00:51:32.329
Kevaundray Wedderburn: Manu is a developer from Prism.

375
00:51:33.690 --> 00:51:34.470
Manu: Yes.

376
00:51:34.610 --> 00:51:38.379
Manu: I think you have to… okay, yes, I can share now.

377
00:51:38.750 --> 00:51:45.020
Manu: Oh, sorry.

378
00:51:49.000 --> 00:51:54.109
Manu: Okay, I'm sorry, I have to close, to close,

379
00:51:54.320 --> 00:52:03.810
Manu: Zoom and to reopen it again, so I won't share my screen now. Yes, Flurry, basically, so, we had,

380
00:52:04.060 --> 00:52:13.459
Manu: June Song and developer, which, created an initial pack, proof of concept on Prism. And, then,

381
00:52:14.010 --> 00:52:17.790
Manu: We are currently adapting the codebase to the latest specification.

382
00:52:18.070 --> 00:52:25.670
Manu: Which is supposed to… Zuh… Post is the latest,

383
00:52:26.360 --> 00:52:40.230
Manu: request on the spec. And yeah, so to help testing, I implemented a standalone dummy prover, which was inspired by the one done by, Kev on Lighthouse.

384
00:52:40.350 --> 00:52:53.359
Manu: And so, just basically, this dummy prover listened to Beacon blocks from SSC, and creates just a dummy proof. This dummy proof doesn't do anything, I mean, it's just an empty thing.

385
00:52:53.630 --> 00:52:58.559
Manu: And, yes, and the proverb published is dummy proof to a Beacon nod via the new,

386
00:52:58.730 --> 00:53:00.969
Manu: execution-proof BigConn API.

387
00:53:02.040 --> 00:53:10.389
Manu: And, yes, and also, I modified the core to this package,

388
00:53:10.560 --> 00:53:18.309
Manu: ATM customers package to… to add the prover directly, to connect the approver directly to a, to a BCANN.

389
00:53:19.280 --> 00:53:24.270
Manu: And I will share my… I will share my slides just in the chat.

390
00:53:24.630 --> 00:53:42.219
Manu: And, yes, the big, thing still to implement is, sign execution proof, the sign scam, which was not really doable with the current state of the spec, but I saw that, Francesco modified this,

391
00:53:42.490 --> 00:53:47.509
Manu: And I will talk to him about the new scam, about signing proofs.

392
00:53:47.930 --> 00:53:52.039
Manu: Thank you, sorry, about the slide sharing.

393
00:53:52.500 --> 00:53:53.989
Manu: And that's all for me.

394
00:53:54.470 --> 00:54:00.469
Kevaundray Wedderburn: Thank you, Monu. Yeah, it's pretty good that we'll be able to have a Lighthouse and a PRISM implementation.

395
00:54:00.580 --> 00:54:06.379
Kevaundray Wedderburn: Soon, soon, TM. Han, do you want to share your screen?

396
00:54:06.930 --> 00:54:07.610
Han Jian: Yup.

397
00:54:12.190 --> 00:54:13.800
Han Jian: Can you see my screen?

398
00:54:19.430 --> 00:54:23.830
Han Jian: So, I would give an update to the Perlinium infrastructure project.

399
00:54:24.370 --> 00:54:32.939
Han Jian: I will focus on the array and ZKBoost, and how we use them to provide the execution proof to the consensus layer.

400
00:54:33.720 --> 00:54:38.220
Han Jian: So, in this project, there are 3 major repos that are used.

401
00:54:38.360 --> 00:54:50.009
Han Jian: The first is the array, which integrates various of the KVN SDK to provide a unified interface for use, and it also provides the Dockerized images

402
00:54:50.540 --> 00:54:56.260
Han Jian: a declarized compiler and server images. The server here is just a HTTP wrapper for the proverb.

403
00:54:57.240 --> 00:55:04.290
Han Jian: And the second repo is the array guest, which provides the execution layer guest program, and it published the compiled ELF.

404
00:55:04.680 --> 00:55:12.570
Han Jian: And the third row is the ZKBoost, which has two… which is the actual component that interacts with the consensus layer.

405
00:55:13.190 --> 00:55:19.470
Han Jian: And inside that, it has two components, the execution, Windows Entry, and the ZK boost server.

406
00:55:20.500 --> 00:55:32.550
Han Jian: And the execution, Windows Sentry and the DK boost server are essentially the relay and proof engine that Francisco just introduced, so I will skip the end-to-end flow here.

407
00:55:32.940 --> 00:55:42.400
Han Jian: And in the ZKBoost server, we have the example script to spin up the whole stack for Lighthouse, so we can test the proven infra easily.

408
00:55:44.120 --> 00:55:47.980
Han Jian: And so far, we have integrated the following DKVMs.

409
00:55:48.110 --> 00:55:58.209
Han Jian: And some of them support GPU proving. And here, the multi-GPU means that we can prove in our multi-GPU, but on the same machine.

410
00:56:00.350 --> 00:56:09.590
Han Jian: And in the area guest repo, so far we have this execution layer guest program available, which allows us to provide multiple

411
00:56:09.780 --> 00:56:14.809
Han Jian: execution proof with different ZKVN and execution layer combinations.

412
00:56:16.460 --> 00:56:33.540
Han Jian: The next step will be fully integrate the whole stack into the Ethereum package, so we can test the proven inform more easily. And also, I would need to clean up a bit to follow the EIP825 spec and naming, and add more metrics to track the pipeline efficiency.

413
00:56:33.880 --> 00:56:36.680
Han Jian: Yep, that's my update. Thanks.

414
00:56:39.750 --> 00:56:40.530
Kevaundray Wedderburn: Thanks, Han.

415
00:56:40.910 --> 00:56:45.359
Kevaundray Wedderburn: there are no questions.

416
00:56:50.580 --> 00:57:02.869
Kevaundray Wedderburn: Okay, Stefan is… I think Stefan is sharing now. Justin made a comment, we should consider integrating ZKBoost clients into CL clients. Yeah, I think that's a good direction.

417
00:57:03.730 --> 00:57:05.680
Kevaundray Wedderburn: Cool. Okay, Stefan?

418
00:57:06.530 --> 00:57:10.060
Stefan Starflinger: Yeah, I didn't want to interrupt, I just wanted to test if I can share.

419
00:57:10.590 --> 00:57:14.539
Stefan Starflinger: Can you see the screen, I hope?

420
00:57:14.540 --> 00:57:15.130
Kevaundray Wedderburn: Yep.

421
00:57:15.680 --> 00:57:27.299
Stefan Starflinger: Perfect. So I just, gonna give a quick summary, what we've been looking into, with the CK team and East Bundle Ops. So, we looked at building versus buying versus renting.

422
00:57:27.450 --> 00:57:38.300
Stefan Starflinger: And there's the option either to build the server ourselves, and then put it in a co-location, to buy a pre-built server, or just to rent from a cloud provider.

423
00:57:38.500 --> 00:57:50.480
Stefan Starflinger: And here is kind of an overview. Of course, the do-it-yourself is still the cheapest, even though the ramp prices have exploded. I'll go through it quickly, but we can talk about it in more detail if you want later on.

424
00:57:50.680 --> 00:58:01.030
Stefan Starflinger: And then kind of the idea is to have two clusters, and right now, this would be, how it would look like if we did just the do-yourself build.

425
00:58:01.300 --> 00:58:13.909
Stefan Starflinger: So we would have 4 GPUs per server, and then four servers would be one cluster, and we would have one development cluster, and one production cluster. That would be the idea right now.

426
00:58:14.360 --> 00:58:19.630
Stefan Starflinger: And these are just some requirements for the setup that we're looking into.

427
00:58:19.760 --> 00:58:24.699
Stefan Starflinger: Not gonna go over it in detail. This would be kind of the setup that we're looking into.

428
00:58:24.820 --> 00:58:34.150
Stefan Starflinger: So just, for 5090 GPUs, it would be good if we can get them to be 3.5 slots or smaller.

429
00:58:34.290 --> 00:58:45.549
Stefan Starflinger: we kind of looked into having the Astos version, because they have pretty good cooling, but we have to look in that, the heat gets pushed out of the back, and not just to the side.

430
00:58:45.780 --> 00:58:49.860
Stefan Starflinger: So we're still investigating here what is the best 5090 version.

431
00:58:50.250 --> 00:58:59.240
Stefan Starflinger: 1590 is considerably cheaper than the 6000 version, but we saw that the 6000, RTX 6000 Pro

432
00:58:59.380 --> 00:59:05.280
Stefan Starflinger: Max-Q version, which is just 300 watts, which is significantly less than 5090.

433
00:59:05.420 --> 00:59:13.960
Stefan Starflinger: Is less performant, but only by 15%, but it's unfortunately so much more expensive as soon as you get into the enterprise market.

434
00:59:14.150 --> 00:59:29.810
Stefan Starflinger: And then for the CPU, we thought about the Threadripper Pro. The newest version was 32 cores, so we got at least 8 cores per GPU, and it has a lot of PCI lanes for all of the,

435
00:59:30.110 --> 00:59:33.440
Stefan Starflinger: TPUs, and then motherboard is,

436
00:59:33.500 --> 00:59:49.580
Stefan Starflinger: fitting one with enough DIMM slots, so we calculated also for the RAM that we need to use all of the slots so that we can use all of the bandwidth of the PCI 5.016 lanes.

437
00:59:49.640 --> 01:00:05.099
Stefan Starflinger: which is, I think, around 256-something gigabytes per second, and with just 4 slots of RAM, we wouldn't max out the total, but with 8 slots, we would be able to utilize the full bandwidth.

438
01:00:05.220 --> 01:00:12.139
Stefan Starflinger: And storage is not unimportant, but we would want 100GB networking between the individual servers.

439
01:00:12.320 --> 01:00:20.259
Stefan Starflinger: So that, we can copy between them, because four machines would be in parallel, working on the proof.

440
01:00:20.570 --> 01:00:26.959
Stefan Starflinger: That's kind of the setup. Here are some comparisons between pre-built systems that we also looked into.

441
01:00:27.120 --> 01:00:29.750
Stefan Starflinger: But I'll keep over that for now.

442
01:00:29.940 --> 01:00:41.610
Stefan Starflinger: And let's maybe look at the comparison. So doing it ourselves, for a 3-year ownership would be around 570 in the co-location.

443
01:00:41.810 --> 01:00:44.180
Stefan Starflinger: We already got, some…

444
01:00:44.630 --> 01:00:56.050
Stefan Starflinger: information from the co-location, how much the setup would be, and how much the monthly cost would be. And here it compares it against, kind of, the pre-built, cheapest

445
01:00:56.350 --> 01:01:04.019
Stefan Starflinger: The pre-built average and the cloud rental, if you would just rent for those years, even with a 5.5% discount.

446
01:01:04.140 --> 01:01:06.830
Stefan Starflinger: It's considerably more expensive.

447
01:01:07.020 --> 01:01:17.419
Stefan Starflinger: And you also don't have any, amortization of the hardware, and at the end of the time, you don't actually own any of the hardware either. So that's also something that's not reflected here.

448
01:01:17.730 --> 01:01:31.879
Stefan Starflinger: And yeah, here's just kind of the co-location hosting breakdown, from the offer that we got. So it's, around… operating around $8,500 a month.

449
01:01:32.020 --> 01:01:36.010
Stefan Starflinger: There's a $16,500, setup cost.

450
01:01:36.330 --> 01:01:46.110
Stefan Starflinger: And then you can see there are the total cost operating without the hardware as well. And here's just a nice overview, I will share the slides as well.

451
01:01:46.350 --> 01:01:52.929
Stefan Starflinger: How much, the… like, just renting versus doing it ourselves would cost.

452
01:01:53.110 --> 01:01:57.219
Stefan Starflinger: Over time, and where, kind of, the total cost of ownership break-even point is.

453
01:01:57.510 --> 01:01:59.960
Stefan Starflinger: And

454
01:02:00.110 --> 01:02:09.870
Stefan Starflinger: Yeah, so the recommendation right now would be not 100% what this slide shows, but kind of this is the general direction.

455
01:02:09.910 --> 01:02:24.770
Stefan Starflinger: So we could also do, like, a hybrid approach, so either just, go all-in, with this do-yourself build, do, or choose a pre-build. We haven't 100% decided yet, this is just a recommendation.

456
01:02:25.100 --> 01:02:40.869
Stefan Starflinger: Or we can do a hybrid where we just get one do-it-yourself build 16 GPU system in the beginning, and then rent the other one. That's still kind of up for discussion, but I hope this kind of gave you a little bit of an overview.

457
01:02:41.130 --> 01:02:44.519
Stefan Starflinger: And here is the appendix, kind of, like, what CPU to choose.

458
01:02:44.860 --> 01:02:50.190
Stefan Starflinger: And any input or anything would be great, if you saw something that might not

459
01:02:50.430 --> 01:02:55.099
Stefan Starflinger: Match up in the, Presentation.

460
01:02:55.460 --> 01:02:57.399
Stefan Starflinger: But I think that's pretty much it.

461
01:02:59.140 --> 01:03:00.329
Kevaundray Wedderburn: From our side.

462
01:03:01.100 --> 01:03:18.189
Kevaundray Wedderburn: Thanks, Stefan. Yeah, so for people on the call, we may run over by 5 minutes, just because I didn't keep time properly, and didn't expect the questions. If you need to leave, these are being recorded, so it's, like, completely fine.

463
01:03:18.300 --> 01:03:23.920
Kevaundray Wedderburn: The next one will be George from the security team, sorry, the cryptography team.

464
01:03:25.030 --> 01:03:42.310
George Kadianakis: Hello guys, let me share my screen. So, I just want to give an update on the ZKVM Security Sprint, an initiative we launched, late last year, with the goal to bring, ZKVM security to 128 bits

465
01:03:42.440 --> 01:03:59.450
George Kadianakis: this year. So, we plan to do this in 3 milestones over, this entire year through an iterated process with the teams, but today, I mainly want to talk about this update blog post we pushed

466
01:03:59.540 --> 01:04:07.920
George Kadianakis: today on the ZKVM team website, and it does three things, mainly. One thing is that it

467
01:04:07.920 --> 01:04:22.750
George Kadianakis: presents a visualization of the timeline and the milestones and stuff for people who are more of the visual kind. So you can see this thing here, and also, for the first milestone, which is at the end of this month.

468
01:04:22.750 --> 01:04:32.849
George Kadianakis: the SoundCalc integration. After talking to Teams, we would like Teams to also integrate their inner segment lookups into SoundCalc.

469
01:04:32.980 --> 01:04:35.869
George Kadianakis: Because that's a big part of the soundness.

470
01:04:35.870 --> 01:04:58.889
George Kadianakis: of the segments, which is the first thing we want to start, looking at the proof system security. So, this is one update that we want the lookups integrated. Many teams have already done it. And the other update is that we published details on the ZKVM architecture white paper, the documentation effort we want to,

471
01:04:58.910 --> 01:05:14.489
George Kadianakis: start. So if you see here, we have a PDF, with how we expect this document to look like. Again, it's going to be done in an iterated manner, and with different milestones, and now you may

472
01:05:14.490 --> 01:05:30.879
George Kadianakis: start understanding why the visual representation is useful. So yeah, please check out the document on how we expect the white paper to look like. If you have any questions, let us know, and yeah, thanks a lot.

473
01:05:33.660 --> 01:05:37.860
George Kadianakis: I think, who's next, Kev? Maybe it's Cody?

474
01:05:37.860 --> 01:05:38.610
Kevaundray Wedderburn: Cody?

475
01:05:42.540 --> 01:05:47.359
Kevaundray Wedderburn: Could you drop a link to the post as well, George, in the chat?

476
01:05:47.360 --> 01:05:48.610
George Kadianakis: Yeah, absolutely.

477
01:05:53.420 --> 01:06:10.580
cody: All right, you all should be able to see my screen. So, this is a report on Project 7, which is the sort of meta-project of security. A lot of what has already been spoken about is relevant to security. What I did was…

478
01:06:10.670 --> 01:06:20.040
cody: Take the, description on the planning repo and try to map it out into some smaller set of higher-level goals.

479
01:06:21.950 --> 01:06:37.730
cody: this is the planning repo, and either implicit or, slightly missing from the diagram that I'll show on the next page are some of these things. So the, audits and bounties, prover incentives.

480
01:06:37.730 --> 01:06:46.279
cody: Security of the supply chain, which was touched on in terms of, like, reproducibility of, guest program verification keys.

481
01:06:46.660 --> 01:06:59.270
cody: And another issue that was raised in the planning repo was relating to security approvers, if they are co-located, or maybe, you know, the fact that GPUs are shared

482
01:06:59.270 --> 01:07:10.540
cody: with the public could lead to, sort of, starvation of those resources, and that's related to pro-reliveness and incentives. Some of that stuff can be wrapped into the bars on the following page.

483
01:07:10.550 --> 01:07:15.730
cody: Which is supposed to be taken with a grain of salt. It's not exactly,

484
01:07:16.050 --> 01:07:33.800
cody: you know, time consistent, because I took some things that are, mapped out exactly in time, like what George just spoke about, where there are specific deadlines, and tried to lay them out with things that are still a bit fuzzy. But I think still it's useful to have a look.

485
01:07:33.990 --> 01:07:40.349
cody: So, yeah, we aim to have optional proofs in Hegetah,

486
01:07:40.830 --> 01:07:53.220
cody: And sort of that itself is a bit of a fuzzy deadline, but working back from that, this is, I don't know, these bars could be something like a month, a month and a half, purposely, they're not laid out in dates.

487
01:07:53.340 --> 01:08:00.750
cody: But I, I imagine grouping the initiatives into the sort of initial, affirmation

488
01:08:01.120 --> 01:08:08.909
cody: grouping. I actually don't know if you can see my mouse, I hope you can, but at the top left, we have a kind of, like, reaffirming

489
01:08:09.040 --> 01:08:24.610
cody: hardware requirements, writing down a threat model, that's something I've started to do and will reach out to people about and share on the next call. But some of this initial setting of the stage and really getting consensus once and for all behind some of these things.

490
01:08:24.620 --> 01:08:34.550
cody: And then we need to also, on a slightly longer scale, figure out what, is a minimum set of tests that we're happy to launch optional proofs with.

491
01:08:34.990 --> 01:08:46.750
cody: And, also what exactly we want from the specs of these ZKVMs. For instance, the consensus clients should contain, or the consensus spec should contain

492
01:08:46.750 --> 01:08:48.779
cody: specs for the ZKVMs.

493
01:08:48.779 --> 01:09:07.890
cody: But we would like other specs, and there's also this notion of the white paper spec that, George and his team has asked for. And I put some of the cryptography team's goals on here, so we have the SoundCalc integration due pretty soon. And the next phase, we work to improve security.

494
01:09:07.899 --> 01:09:17.760
cody: Of the proving systems, thinking about the, diversity strategy, where we have many proofs to be verified. We need… we want those,

495
01:09:17.810 --> 01:09:24.099
cody: Proofs to be uncorrelated, you know, in terms of, say, dependencies for the guest programs and the provers.

496
01:09:24.430 --> 01:09:35.329
cody: And, we want to also start to think about, which ZKVMs… what… how should we choose what… which ones will be, whitelisted?

497
01:09:35.520 --> 01:09:38.040
cody: what that looks like.

498
01:09:38.109 --> 01:09:56.780
cody: And, yeah, also, I guess, validating by building out these clusters that, Stefan just spoke about. We need to make sure that those hardware requirements are viable. I mean, we have a lot of data from E3S, but it's good to, to be, have an, you know, at least the EF internally, building some of this stuff.

499
01:09:57.080 --> 01:10:11.620
cody: And feeling really, really confident about that. And then at this point, yeah, we can make some decisions. And then in the next phase, we work even more to improve security of testing, building some monitoring, making sure that everything is reproducible.

500
01:10:12.080 --> 01:10:25.469
cody: working on specs, improving security of the proving systems. And then, at some point, we have to choose, which… which ZKVMs, EVMs are… we're really confident about, and what…

501
01:10:25.470 --> 01:10:41.260
cody: is a good, diversity requirement. It might not just be K of N, because if some set of K is highly correlated, that maybe is, no good. And then we have this phase where we think about incident response, we have to monitor for stability and,

502
01:10:41.430 --> 01:10:46.370
cody: We need to sort of test out our incident response and, now look at the specs.

503
01:10:46.810 --> 01:10:52.060
cody: So, yeah, then, for mandatory proofs, well, like, the scope of this call is not really…

504
01:10:52.340 --> 01:11:03.349
cody: on mandatory proofs, but since it was represented in the planning repo, I mention here some additional or expanded requirements, specifically calling out formal verification.

505
01:11:03.680 --> 01:11:12.429
cody: Is, likely a requirement for mandatory, but perhaps not for optional. That doesn't mean we won't have significant formal verification in place.

506
01:11:12.700 --> 01:11:14.960
cody: Though, before, optional proofs.

507
01:11:15.470 --> 01:11:21.110
cody: And yeah, so what's next? Well, I'll keep track of this, stuff, and…

508
01:11:21.240 --> 01:11:25.140
cody: You know, keep track of ownership of these things in a loose sense.

509
01:11:25.700 --> 01:11:37.680
cody: And report on progress in these calls, and we're making monthly updates to the planning repo, and we should discuss, in these calls, and also on the ETH R&D Discord.

510
01:11:38.220 --> 01:11:39.990
cody: That is all from me, thank you.

511
01:11:44.400 --> 01:11:49.629
Kevaundray Wedderburn: Thanks, Cody. There are no questions. Ignacio will give…

512
01:11:49.990 --> 01:12:01.670
Kevaundray Wedderburn: He's talking the next breakouts, just to give more space for this one. And then we have Alex H, and then Farah from Eve Profs. And then we can close out. Yeah, thanks guys for staying on.

513
01:12:02.830 --> 01:12:06.290
Alex Hicks: Yep, I'll quickly share my slides.

514
01:12:06.940 --> 01:12:14.520
Alex Hicks: So my slides are also in the chat, if anyone wants to have them for later, there are links to the website, and there are links to…

515
01:12:14.700 --> 01:12:18.849
Alex Hicks: the Telegram group, where some of that work is discussed.

516
01:12:19.030 --> 01:12:24.249
Alex Hicks: so it says I'm screen sharing, but I can't see that I'm screen sharing.

517
01:12:24.360 --> 01:12:27.110
Kevaundray Wedderburn: I don't know if… Yeah, I think you can confirm.

518
01:12:27.310 --> 01:12:28.520
Alex Hicks: Okay, perfect.

519
01:12:28.520 --> 01:12:30.100
cody: I see your… Oh, we're seeing the Zoom.

520
01:12:30.100 --> 01:12:31.310
Kevaundray Wedderburn: screen. Oh, yeah.

521
01:12:31.730 --> 01:12:41.059
Alex Hicks: Alright, it should be fine now. Okay, so, anyway, there's this big former application project, I'm gonna try to speed this thing, you know, speed through quick updates.

522
01:12:41.060 --> 01:12:52.650
Alex Hicks: There was two tracks. There's the RISC-VKVM track, where we're looking at, you know, the circuit, and particularly the RISC-V circuits and precompiles, and as part of that, the cell RISC-V specification. There's the EVM track, where we're looking at.

523
01:12:52.700 --> 01:12:58.190
Alex Hicks: the guest program, EVM STF running on RISC-V, and trying to assess that that is…

524
01:12:58.190 --> 01:13:15.629
Alex Hicks: you know, running on RISC-V and compiled to RISC-V, ideally bug-free, in a way that can be shown equivalent to a formal EBM specification. And there's a cryptography track, which is about specifications and, you know, formally verifying the proofs of security for the proof systems, and kind of cryptographic primitives, which are used by ZKVMs.

525
01:13:15.690 --> 01:13:22.470
Alex Hicks: To give a quick update on every track, for the ZKVM track, we have some reasonably short-term targets.

526
01:13:22.470 --> 01:13:39.349
Alex Hicks: So we've now finished extracting the official RISC cell specification to lean. This is a general-purpose cell… cell-to-lean extraction. It supports every RISC5 extension, it supports every other ISA that is defined in cell, for that matter. Obviously, we haven't, kind of, tested this as much.

527
01:13:40.420 --> 01:13:48.370
Alex Hicks: There are also extractions, you know, for Rock and Hawthora and Isabel, other proofs of assistance. We're not using them, but in principle, they're usable. I think to rock one in particular, it's fairly polished.

528
01:13:48.380 --> 01:14:08.359
Alex Hicks: We've been able to use this specification to get proofs done for the resource circuits of several ZKVMs. This includes SPE1, although memory consistency hasn't been verified yet. That'll happen. It includes OpenVM, they released this this week. Congratulations and big thanks to both of these for obviously taking the initiative and co-funding this.

529
01:14:08.680 --> 01:14:26.119
Alex Hicks: we'll be, obviously, doing this with the Odyssey KVMs, you know, kind of ideally ahead of grams of them. There is no, kind of, specific preference in ordering. It comes down to, you know, when teams have felt ready to do it in terms of having stable circuits and things like this. And just a quick note, there are some, you know.

530
01:14:26.120 --> 01:14:40.579
Alex Hicks: assumptions that are done regarding lookups, which is that, you know, the semantics of the lookups are correct, and things like this. We'll try to address these, as much as possible, maybe before Glamsterdam, maybe after Glamsterdam, but certainly before Glamsterdam, we want to have

531
01:14:40.580 --> 01:14:48.859
Alex Hicks: you know, kind of ZKVMs that will have their constraints for the develop codes and memory consistency checks and all of this all done, and in a state of maintenance.

532
01:14:49.330 --> 01:14:52.239
Alex Hicks: We're also looking at precompiles, of course.

533
01:14:52.240 --> 01:15:14.010
Alex Hicks: We are able to verify precompiles in the same way that we verify, you know, RISC-V constraints. For example, I mean, one highlight has been verifying the Ponk E3 catch, in, in Rock, actually, not in Lane, and we can do more precompiles. The main issue with precompiles is that, we have several of the KVMs, they all have many precompiles, verifying them all is

534
01:15:14.010 --> 01:15:32.140
Alex Hicks: doable in principle, but a bit of a time sink, and there's a bit of uncertainty regarding how many precompiles the ZKV's gonna have. So we're just looking at, you know, maybe how to scale this, maybe how to use pre-compiles written in Lean, which are easier to verify. We'll see what to do with that, you know, as we get close to Glamsterdam and around that time.

535
01:15:32.140 --> 01:15:43.809
Alex Hicks: We're also verifying order precompiles, you know, with Powder and Satora. This is ongoing. I think order precompiles are great. I hope this helps, you know, drive the adoption of order precompiles.

536
01:15:43.810 --> 01:16:07.549
Alex Hicks: which seemed like it would also solve the issue of having too many manual precompiles to verify. There are a bunch of miscellaneous other things going on. We have lean DSLs for start kits, which are able to define precompiles and actually prototype VMs as well at this point. We have LLZK, which are these MLAR… family of MLAR data for, both constraints and witness generation. These are all ongoing, you know, there were kind of SMT backends, lean backends, verified.

537
01:16:07.550 --> 01:16:10.930
Alex Hicks: being developed for all of this, I won't go into detail here.

538
01:16:11.780 --> 01:16:21.089
Alex Hicks: For the EVM track in 2025, we… we… there was a tooling developed with, runtime verification. We were able to verify

539
01:16:21.090 --> 01:16:45.890
Alex Hicks: that the execution of opcodes on RISC-V, that is, taking RVM or RVM interpreter specifically and compiling that to what at the time was the SP1 RISC-V 32-bit target, and then doing equivalence proofs since KVM was doable. This is… this hasn't been updated yet to, you know, the new 64-bit RISC-V target that is being standardized on, and we'd also want to see how to extend that to, you know, the guest program slash STF as a whole.

540
01:16:45.890 --> 01:16:52.019
Alex Hicks: as well as, obviously, supporting more guest programs. It's, again, there's an issue of this is kind of…

541
01:16:52.290 --> 01:17:09.790
Alex Hicks: doable, it's unclear how robust the toolchain is. Different guest programs, obviously produce different assembly that may be more or less nice to look at and deal with. And there's a question of balancing costs of doing all of this versus the assumptions that we're making about, you know, client diversity as a hedge against bugs.

542
01:17:09.790 --> 01:17:17.900
Alex Hicks: Especially this year, because, budgets, you know, kind of EF-wide are somewhat reduced this year, and so I'm looking at this at the moment, and we'll probably have a

543
01:17:17.990 --> 01:17:29.669
Alex Hicks: more of an update on this, you know, very soon. And same there's a question about, you know, whether it makes sense to have a kind of canonical guest program, which would obviously be something that comes with very high assurance in the form of

544
01:17:29.670 --> 01:17:39.000
Alex Hicks: you know, a guest program that is, generated from a formal specification and compiled via a verified compiler, and, you know, ideally performant enough.

545
01:17:39.560 --> 01:17:40.090
Alex Hicks: Sorry.

546
01:17:40.090 --> 01:17:44.299
Kevaundray Wedderburn: Your screen seems to be, there's something.

547
01:17:44.300 --> 01:17:51.680
Alex Hicks: Choppy. Okay, let me… I'll stop sharing and restart sharing, and that should probably be the fastest way to fix it.

548
01:17:53.440 --> 01:17:57.220
Alex Hicks: Okay, let me know if this is better.

549
01:17:57.760 --> 01:18:05.720
Alex Hicks: So yeah, the EVM track at the moment is a bit in flux, because we also have many new guest programs, and obviously the standardization at the risk-back target.

550
01:18:06.040 --> 01:18:17.160
Alex Hicks: Now the cryptography track, also to go over that very quickly, this is more… this is a bit less shorter term, maybe a bit more medium term, suddenly thinking of mandatory proofs, as Cody had on his slides.

551
01:18:17.160 --> 01:18:27.120
Alex Hicks: We have Rclip. This is a library of formally verified executable specifications for proof systems. This verifies everything down to the underlying coding theory. We are starting to have…

552
01:18:27.160 --> 01:18:35.180
Alex Hicks: specifications in there, we have interactive fry, we have sum check, we're also starting to have, you know, fully executable,

553
01:18:35.500 --> 01:18:49.039
Alex Hicks: specs. The goal here is obviously to be able to verify, in particular, the Rust verifiers. We have a tool called Hacks, which is being developed with a lean backend for this purpose. We're starting to use Hacks, we're starting to verify some Rust code with Hacks.

554
01:18:49.100 --> 01:19:06.600
Alex Hicks: there's a bit of a challenge in the complexity of features that are used in Rust libraries. By features here, I mean features of the Rust language, which, which have varying levels of support by hacks, because we don't have… we don't have formal semantics for Rust, obviously, and so that tooling has to be… support for additional features is done on a, kind of.

555
01:19:06.600 --> 01:19:19.160
Alex Hicks: one-by-one basis, and can take a bit of time. This will be ongoing in the next year or so. It won't be done before optional proofs. We're obviously aiming to get it done, you know, before mandatory proofs.

556
01:19:19.810 --> 01:19:40.479
Alex Hicks: And then on the kind of miscellaneous side, again, you know, we're also looking at actually compiling our lean specifications to optimize the MLIR dialects, and see if, potentially, if we just generate faster code than what is generally understood from Rust, and potentially we can verify, actually, these MLIR dialects, because we don't need too many. Maybe we're able to skip verifying, you know, Rust code in some instances, and making our life easier.

557
01:19:40.480 --> 01:19:57.249
Alex Hicks: again, this is ongoing, and especially this part is slightly exploratory for now. Just to wrap up, we have progress ongoing on each track. There's a mix of short-term targets, like the RISC-V circuit verification, and the pre-compass to an extent that we want to wrap up, you know, around Amsterdam time.

558
01:19:57.250 --> 01:20:06.489
Alex Hicks: There are more, kind of, medium-long-term targets with specs for the proof systems, which, obviously, the proof systems now are more complicated than, you know, just Fry, or just SunCheck, or whatever.

559
01:20:06.490 --> 01:20:13.389
Alex Hicks: And obviously trying to push for great integration of formal verification in the development and testing process to try and make all of this

560
01:20:13.390 --> 01:20:34.270
Alex Hicks: you know, smoother, and we're driving costs down, I think, for a lot of these, formation tasks as well, which is one… one neighbor, see, to make this sustainable. We're aiming to be robust at changing this tax, so that if people rewrite their circuits, change the gas program, whatever, we can handle this. Again, this comes down to kind of making this economically sustainable, and putting upfront effort into tooling to make this happen.

561
01:20:34.280 --> 01:20:51.020
Alex Hicks: So yeah, well, I have high expectations that things like the risk-fired circuits can all be done by Glamsterdam. We're not treating this as a blocker, because we can't do optional processing without this, if we happen to be, you know, delayed by a week or whatever, but I still expect this to happen, regardless.

562
01:20:51.020 --> 01:20:55.990
Alex Hicks: And then we want to obviously use the official proofs period to establish, you know, robust maintenance practices.

563
01:20:56.110 --> 01:21:05.400
Alex Hicks: Before we do mandatory proofs, because, obviously, maintaining the proofs, maintaining the link between the proofs and the software that's verified is something that is going to be a very important,

564
01:21:05.750 --> 01:21:29.400
Alex Hicks: a very important part of, of moving forward and handing upgrades and things of that kind. We have a website, verified-dkvm.org. It was updated a bit recently, so there's a… the grant list and, you know, recent talks and blog posts and all of this, up to date. There is more documentation coming soon regarding, more specific details of what was done on the different grants, as well as

565
01:21:29.400 --> 01:21:49.310
Alex Hicks: some maybe more research-y, challenges and topics that indicate, kind of, some of the future work. There's also a Telegram group, there's a link here, there's a link to the slides in the Google Meets chat you can click on, and, there's, it's not the most active Telegram group. There are a lot of projects, some have split up into, you know, other channels.

566
01:21:49.310 --> 01:21:52.700
Alex Hicks: But it's a good way to follow what's going on, overall.

567
01:21:52.980 --> 01:22:04.850
Alex Hicks: That's it from me. I guess I'm happy to take any questions unless, Kev says no, and we need to leave it here. But, but yeah, happy to also answer questions asynchronously on Telegram, email, Signal, whatever else.

568
01:22:05.660 --> 01:22:09.180
Kevaundray Wedderburn: Yeah, maybe take questions async.

569
01:22:09.180 --> 01:22:09.920
Alex Hicks: Yup.

570
01:22:10.440 --> 01:22:12.129
Kevaundray Wedderburn: Farah, did you wanna…

571
01:22:12.320 --> 01:22:14.399
Fara Woolf: Yep, yep, let me share my screen.

572
01:22:15.220 --> 01:22:17.360
Kevaundray Wedderburn: Thank you again, guys, for staying on.

573
01:22:19.070 --> 01:22:32.200
Fara Woolf: Yeah, so, we're testing all kind of new ZKVMs proving mainnet on ETHBrooks first, so if you're a new team, you can… we'll probably onboard you through this staging app, first, so…

574
01:22:32.450 --> 01:22:40.909
Fara Woolf: I'll drop a link to that in the chat, but if you come to the sign-in button, actually, you'll be able to go through a sign-up process if you click on the sign-up

575
01:22:41.370 --> 01:22:42.959
Fara Woolf: Button here.

576
01:22:43.170 --> 01:22:57.840
Fara Woolf: It should load, and so you can basically sign up as a new team. I'll receive kind of a notification that you're trying to sign up, and I'll approve you, and you'll receive kind of a notification with an API key, in the email.

577
01:22:57.870 --> 01:23:09.520
Fara Woolf: And then once you're a new team, you'll have a dashboard button here, and you'll be able to come into a dashboard and create a new ZKVM.

578
01:23:09.610 --> 01:23:18.229
Fara Woolf: And so you'll… you can see, once you're onboarding, the security metrics and the performance metrics that you'll need to fill out.

579
01:23:18.260 --> 01:23:33.759
Fara Woolf: Once you create a new ZKVM, I'll also receive a notification to review it and approve it, so you'll go into this awaiting review status. You can also edit, make any edits to it, and I'll receive a notification to approve those, too.

580
01:23:33.870 --> 01:23:47.389
Fara Woolf: And so then also you'll be able to create a cluster here to… once the ZKVM is there, and you'll be able to then test the ZKVM that you're, onboarding with.

581
01:23:47.730 --> 01:24:00.439
Fara Woolf: Once you're approved, you'll come into this Coming Soon tab here, and the metrics you won't be able to see yet, but once you actually have a cluster and you're submitting a proof, you'll become active.

582
01:24:00.550 --> 01:24:19.260
Fara Woolf: And so then all of the metrics that you filled out and that we're tracking, you'll be able to… to see here. And then we'll be tracking, you'll… you'll come to… when you're submitting the proofs, this API documentation will help you here. You'll actually self-report a proving time that we track.

583
01:24:19.320 --> 01:24:29.209
Fara Woolf: That helps us also track the average cost, and then we, do the total time to proof, where we're using the block time and the,

584
01:24:29.240 --> 01:24:39.880
Fara Woolf: the time that you submit the proof, and so we're tracking those… those things. So, yeah, reach out to us on Telegram, too, but I'll drop the link to the staging app in the… in the chat.

585
01:24:44.520 --> 01:24:46.119
Kevaundray Wedderburn: Great. Thank you, Farah.

586
01:24:47.850 --> 01:24:50.800
Kevaundray Wedderburn: We have a question…

587
01:24:51.200 --> 01:24:56.880
Kevaundray Wedderburn: If a guest program team is not ready to be on EVE Proofs yet, does it make sense to sign up ahead of time?

588
01:24:59.940 --> 01:25:04.179
Fara Woolf: Yeah, I mean, I don't know why not. I think it's totally fine to sign up, yeah.

589
01:25:05.480 --> 01:25:06.320
Kevaundray Wedderburn: Cool.

590
01:25:07.520 --> 01:25:23.640
Kevaundray Wedderburn: And yeah, you can reach out to Farah async about, about doing this. Okay, so we're about 19 minutes over time. Thank you all for staying on, for the extra 19 minutes. This was the first breakout call.

591
01:25:24.590 --> 01:25:37.520
Kevaundray Wedderburn: I would say please join the Discord, our R&D Discord, to find out, sort of, what's happening async. A lot of things are happening between the monthly calls, and yeah, would be great to just talk with you guys.

592
01:25:40.290 --> 01:25:43.289
Kevaundray Wedderburn: If that's it, I will see you in about 4 weeks.

593
01:25:47.270 --> 01:25:48.180
Alex Hicks: Thanks.

594
01:25:48.550 --> 01:25:49.970
Guillaume: secure?

595
01:25:49.970 --> 01:25:50.780
Ladislaus: Thanks, Kev.

