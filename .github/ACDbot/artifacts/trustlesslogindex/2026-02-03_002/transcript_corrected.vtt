WEBVTT

1
00:07:11.430 --> 00:07:12.360
Zsolt Felföldi: Hello?

2
00:07:21.580 --> 00:07:25.979
Zsolt Felföldi: Thanks for coming. Yeah, apparently not a lot of people.

3
00:07:26.310 --> 00:07:30.020
Zsolt Felföldi: But… That's fine.

4
00:07:31.320 --> 00:07:34.899
Łukasz Rozmej: Yeah, a bit of… not a crowd.

5
00:07:34.900 --> 00:07:36.780
Zsolt Felföldi: Yeah, I mean…

6
00:07:37.060 --> 00:07:43.310
Zsolt Felföldi: I know this is just the topic that might interest a few people, and also, yeah, I…

7
00:07:43.450 --> 00:07:50.709
Zsolt Felföldi: I'm aware I really have to work on my presentation skills, but I think we can I… at least…

8
00:07:51.680 --> 00:07:56.460
Zsolt Felföldi: I can, I can, I can show what I have, and that's good, so…

9
00:07:56.600 --> 00:08:03.119
Zsolt Felföldi: maybe wait, like, I don't know… Oh, it's 4.05 now, so…

10
00:08:07.300 --> 00:08:10.370
Zsolt Felföldi: Let's wait one more minute, and then, yeah, let's start.

11
00:08:30.170 --> 00:08:35.309
Zsolt Felföldi: Until then, I will just… Trying to share my screen.

12
00:08:36.230 --> 00:08:38.679
Zsolt Felföldi: Well, no.

13
00:08:42.990 --> 00:08:43.870
Zsolt Felföldi: Whoa.

14
00:08:45.880 --> 00:08:50.280
Zsolt Felföldi: It's just… Do a slideshow, okay.

15
00:08:58.480 --> 00:08:59.829
Zsolt Felföldi: Wait, no.

16
00:09:00.290 --> 00:09:01.340
Zsolt Felföldi: I just…

17
00:09:05.700 --> 00:09:08.379
Zsolt Felföldi: Okay, can you see the slide?

18
00:09:10.240 --> 00:09:11.010
Łukasz Rozmej: Yes.

19
00:09:11.880 --> 00:09:12.740
Zsolt Felföldi: Alright.

20
00:09:15.100 --> 00:09:17.880
Zsolt Felföldi: Okay, I think, yeah.

21
00:09:18.830 --> 00:09:22.269
Zsolt Felföldi: Let's just… I, I will, I will, I will,

22
00:09:22.610 --> 00:09:25.390
Zsolt Felföldi: Go through this, and yeah.

23
00:09:26.230 --> 00:09:30.579
Zsolt Felföldi: I will… I think I will present this multiple times anyways.

24
00:09:31.430 --> 00:09:36.820
Zsolt Felföldi: Let's just, you know… Okay, so,

25
00:09:37.130 --> 00:09:40.679
Zsolt Felföldi: So now, now I, I, I, just, like…

26
00:09:41.010 --> 00:09:47.050
Zsolt Felföldi: figured out the details of this new thing I want to propose, and I think I managed to make it

27
00:09:47.220 --> 00:09:49.740
Zsolt Felföldi: Even simpler, and

28
00:09:50.070 --> 00:10:08.069
Zsolt Felföldi: Yeah, so, so the basic thing is, the basic, basic, structure that I want to, show is… it's, I just call them index tables, and, so these are… yeah, and I will have some drawings that will show it better, but,

29
00:10:08.130 --> 00:10:27.819
Zsolt Felföldi: These are an ordered list of events, and one event can be a block hash, a transaction hash, a log address, or a log topic, and this… this is all tree hashed, and I will also show why… how that can be used for searching and proving.

30
00:10:28.310 --> 00:10:42.619
Zsolt Felföldi: And so one important thing is that an index table is generated either from a single block or a number of blocks, but they are always generated when, like, those blocks are finished.

31
00:10:43.000 --> 00:10:49.270
Zsolt Felföldi: And, and, and they are not. I mean, I mean, I'm in, I'm in, this…

32
00:10:51.000 --> 00:11:05.170
Zsolt Felföldi: So, the new tables are generated from new blocks, and since these are just sorted lists, they can be merged together, so that's how this structure evolves.

33
00:11:05.170 --> 00:11:12.400
Zsolt Felföldi: The complete table is never modified. If the chain is rolled back, then some tables might be discarded and regenerated, but yeah.

34
00:11:12.400 --> 00:11:15.099
Zsolt Felföldi: Those are just, small tables at the…

35
00:11:15.250 --> 00:11:29.929
Zsolt Felföldi: And… and I was… yeah, okay, let's just, so this is… this is, this is a chronological order of, of, of, of, events in an example, and, yeah, I just…

36
00:11:30.070 --> 00:11:40.649
Zsolt Felföldi: I have this… this… I have few events, like, there are four, so this is a… this is an index table that covers four blocks, and there's…

37
00:11:40.740 --> 00:11:58.109
Zsolt Felföldi: there's some empty blocks, there's a block when there's a transaction with two log events, a WA transfer, and a USDT transfer, and the second transaction with a withdrawal, and another block with another USDT transfer, so this is…

38
00:11:58.430 --> 00:11:59.340
Zsolt Felföldi: just…

39
00:12:02.230 --> 00:12:12.029
Zsolt Felföldi: enough for some simple examples. And, yeah, as you can see. Now, this is the chronological ordering, so this is not how the table is hashed.

40
00:12:12.100 --> 00:12:28.529
Zsolt Felföldi: So here, every entry has a block number, transaction number inside of the block, and log… index of the log inside of the transaction, and each entry has a type and a value, which is 32 bytes.

41
00:12:28.870 --> 00:12:34.679
Zsolt Felföldi: And, the way the table is generated is that it's,

42
00:12:34.980 --> 00:12:53.710
Zsolt Felföldi: it's sorted, and here I also reordered the columns so that it represents the sorting order, so it's sorted by event type first, and then by value, and then by block number, and yeah, so the position.

43
00:12:53.960 --> 00:13:00.930
Zsolt Felföldi: And, the whole thing is, tree-hashed, the way I…

44
00:13:01.830 --> 00:13:09.590
Zsolt Felföldi: imagine that now, probably the easiest thing is just use the SSZ list hashing, so…

45
00:13:09.590 --> 00:13:25.869
Zsolt Felföldi: And since this is an immutable thing, and we know, like, in advance the number of items, so we can just create a list with an appropriate capacity. So this list has

46
00:13:26.080 --> 00:13:28.699
Zsolt Felföldi: Yeah, I guess it has 5 levels of…

47
00:13:29.080 --> 00:13:42.560
Zsolt Felföldi: nodes, and it has… it has a total capacity of 32 items, but now we have 22, so if we have more than 22… more than 32 items, then we are going to have a

48
00:13:42.730 --> 00:13:46.830
Zsolt Felföldi: More, more, tree levels, and yeah,

49
00:13:47.980 --> 00:13:52.069
Zsolt Felföldi: And, and the individual items.

50
00:13:52.080 --> 00:14:11.779
Zsolt Felföldi: So now, maybe we are… maybe this could be optimized, but the way I imagine it now, we can just have a 64-byte encoding. We don't necessarily need 64 bytes, but but yeah, we need more than 32, so it's going to be two nodes in the binary merco tree anyways.

51
00:14:11.930 --> 00:14:17.839
Zsolt Felföldi: And, I think the nicest way, probably, is to use an encoding.

52
00:14:17.960 --> 00:14:30.150
Zsolt Felföldi: where the numbers are big and beyond. I mean, the event type is not really relevant because it's one byte, but maybe later we can have more event types for some reason. Anyways, but the position…

53
00:14:30.160 --> 00:14:38.990
Zsolt Felföldi: Numbers are also encoded in big India, so the whole thing can be, just classically ordered the same way it is hashed.

54
00:14:39.160 --> 00:14:41.140
Zsolt Felföldi: And, yeah, maybe.

55
00:14:41.760 --> 00:14:43.429
Zsolt Felföldi: If the… yeah.

56
00:14:45.160 --> 00:14:46.660
Zsolt Felföldi: this, this, this…

57
00:14:46.660 --> 00:15:07.119
Zsolt Felföldi: Looks probably simple enough, and yeah, in some cases, the transaction and log index is not applicable, because we have entries for the block hashes themselves, there's then no transaction index, and also we have entries for the transaction hashes, then there's no log index, so these are just left as zeros in the encoding.

58
00:15:09.810 --> 00:15:20.569
Łukasz Rozmej: Could we represent them with something else, and then we don't potentially need the type, right? If we have, like, optional, or a null, or whatever.

59
00:15:21.220 --> 00:15:25.699
Zsolt Felföldi: So, what… I don't understand.

60
00:15:25.760 --> 00:15:37.179
Łukasz Rozmej: Okay, so potentially, we could infer from, missing data on the transaction and log columns, the type of the…

61
00:15:37.430 --> 00:15:39.540
Łukasz Rozmej: Row, and then we don't need.

62
00:15:39.540 --> 00:15:48.869
Zsolt Felföldi: The type column? Maybe we could. Well, actually, we could, yeah, so, so we could do that. We could have,

63
00:15:48.940 --> 00:16:03.839
Zsolt Felföldi: another column, which could be, like, the topic index inside of the log, and then probably… and yeah, we could use some other value instead of zero for the missing entries, and yeah, so this would tell all the necessary information, but

64
00:16:03.840 --> 00:16:16.600
Zsolt Felföldi: I mean, this is not about some tight encoding, this is… or this is just for hashing, it doesn't have to be optimal, and also the important thing is that it is sorted,

65
00:16:16.600 --> 00:16:21.199
Zsolt Felföldi: By type first, and then by value, so…

66
00:16:21.660 --> 00:16:34.079
Zsolt Felföldi: I just assumed… I mean, I mean, we can have any kind of representation, hashing representation, and we can still have the same sorting. I just felt this is probably nice, because

67
00:16:34.320 --> 00:16:53.870
Zsolt Felföldi: like the, the hashing format and the sorting, format, sorting, rules are, related, but yeah, I mean, if there's any reason to use another encoding, we can have that it will not fundamentally change anything.

68
00:16:55.140 --> 00:16:57.760
Zsolt Felföldi: Anyway, so this is,

69
00:16:57.880 --> 00:17:06.290
Zsolt Felföldi: This is the table. This is one table. And we have multiple tables, because one table is just… so this is just, like, 4 blocks.

70
00:17:06.630 --> 00:17:12.730
Zsolt Felföldi: And so this is how this would go into, Consensus.

71
00:17:13.650 --> 00:17:23.969
Zsolt Felföldi: So, we generate a single block table for every new block, and that goes instantly into the header.

72
00:17:24.069 --> 00:17:40.539
Zsolt Felföldi: And I tried to do this drawing, so this arrow shows that we are now, like, at block 81, and then the table of block 81 instantly goes into the header.

73
00:17:40.750 --> 00:17:50.489
Zsolt Felföldi: And we also, generate larger tables. This can be generated by merging the smaller tables, and

74
00:17:50.730 --> 00:18:05.389
Zsolt Felföldi: And these are added to the header with some delay, so that we don't have to just… so this can be processed somewhat asynchronously, and maybe this is…

75
00:18:06.090 --> 00:18:14.419
Zsolt Felföldi: Good for processing latencies. And these, tables are,

76
00:18:14.610 --> 00:18:33.580
Zsolt Felföldi: hashed into a simple chain, because, I mean, this is good enough, we don't necessarily need, some, some other, hashing into… with some tree index, with some table indexes. We could do that, but, but, the thing is that, in practice,

77
00:18:33.820 --> 00:18:42.580
Zsolt Felföldi: with the… with the small tables, we will only ever need the last few ones. So this is, like, yeah, for the hashing, these tables all…

78
00:18:43.140 --> 00:18:52.510
Zsolt Felföldi: are hashed into the latest, tables, representation, but, if there's an… I mean, they… if…

79
00:18:53.380 --> 00:19:09.590
Zsolt Felföldi: a provider wants to prove something, then they will not use the old single block tables, because they are less efficient. They will use, at most, 3 or maybe 4 small tables. They will use

80
00:19:09.750 --> 00:19:13.859
Zsolt Felföldi: Like, and this, the, in the, in the, in the…

81
00:19:14.490 --> 00:19:30.939
Zsolt Felföldi: 16 block table row, so this is the third from the bottom. This asynchronous processing is also shown, so that, in this case, at block 81, we already have all the

82
00:19:30.940 --> 00:19:43.249
Zsolt Felföldi: 4 block tables, and they are being merged into the 16 block table, but it's not added to the consensus yet, because, yeah, let's leave some time to process it.

83
00:19:43.380 --> 00:20:02.950
Zsolt Felföldi: And, therefore, it's possible that we have to use four, so we use, in worst case, four, four block tables, and then we can use 16 block tables, and, and, and 64 block tables also, and the bigger ones are always more efficient.

84
00:20:03.350 --> 00:20:10.690
Zsolt Felföldi: And, in this proposal, I… I… I propose that we do not,

85
00:20:11.290 --> 00:20:17.230
Zsolt Felföldi: hash bigger tables into consensus, because that would… so with…

86
00:20:17.230 --> 00:20:33.910
Zsolt Felföldi: So with the requirements for generating this structure is that, I mean, the initialization doesn't even need any kind of extra wire protocol or anything. You just have to have the last, I think, 80 or 80 few blocks available.

87
00:20:33.910 --> 00:20:38.800
Zsolt Felföldi: And, yeah, I think that's… that's a reasonable requirement.

88
00:20:38.950 --> 00:20:49.019
Zsolt Felföldi: And and I don't want to require every, node to, have, like, a long chain history,

89
00:20:49.250 --> 00:20:58.999
Zsolt Felföldi: And what we can do, and yeah, I will just get to that also a bit later, we can… we can generate bigot tables with ZK proofs.

90
00:20:59.120 --> 00:21:18.170
Zsolt Felföldi: And, and this is… this is good because, I mean, with ZK proofs, if we want to generate the whole index for every new block, that's going to be really expensive and still going to have some latency, so I think… I think for the… for the recent chain history, having these tables in consensus makes sense.

91
00:21:18.200 --> 00:21:34.049
Zsolt Felföldi: And for, for, like, the long-term history, it's probably better to just, like, some bigger info providers probably can do it even altruistically, or share the effort. Yeah, so this is, this is something that

92
00:21:34.120 --> 00:21:43.879
Zsolt Felföldi: still needs to be figured out, but but we can use bigger tables also, but I think we… now I think we should not add them to…

93
00:21:43.990 --> 00:21:53.530
Zsolt Felföldi: to the headers. And now I will also, show how the search and the proof will… will work, because that's interesting.

94
00:21:53.750 --> 00:21:58.909
Zsolt Felföldi: And, yeah, so this, this, this example is, really,

95
00:21:59.690 --> 00:22:04.560
Zsolt Felföldi: The most basic one, so the most basic kind of proof

96
00:22:04.790 --> 00:22:18.449
Zsolt Felföldi: And this is for one table, so I just go back one slide. So the thing is, if we want to search the entire block history, then we will use multiple tables, like, bigger ones, and then at the end, some smaller ones.

97
00:22:18.450 --> 00:22:25.030
Zsolt Felföldi: But this is just how we prove the existence or non-existence of something in one table.

98
00:22:25.050 --> 00:22:40.980
Zsolt Felföldi: And the simplest case is when we are looking for something that doesn't exist, and we generate an exclusion proof. And yeah, usually this is the most important feature of this whole thing, because inclusion is usually easier to prove than exclusion.

99
00:22:41.100 --> 00:22:49.869
Zsolt Felföldi: And, yeah, so this is the most basic case. Let's assume we are looking for a non-existent, some random transaction hash.

100
00:22:50.300 --> 00:22:51.850
Zsolt Felföldi: And,

101
00:22:51.970 --> 00:23:03.360
Zsolt Felföldi: What the prover does is it finds where this entry should be in the table, and checks whether it's there or not.

102
00:23:03.360 --> 00:23:13.430
Zsolt Felföldi: And this can be done either with a binary search, or probably with a database representation. It's more efficient to just

103
00:23:14.990 --> 00:23:33.780
Zsolt Felföldi: like, store the bigger table in chunks and somehow build a search tree within a chunk level, so, like, we just share the root chunk and then go up with loading high-level chunks from the database, but anyway, that's implementation detail.

104
00:23:33.780 --> 00:23:47.060
Zsolt Felföldi: So the thing is that it is a sorted list, and we can say that there are these two red lines, and, we don't see this, this, this, this transaction hash, but, we can find, like,

105
00:23:47.240 --> 00:23:50.899
Zsolt Felföldi: This would go between these two red lines, if it…

106
00:23:51.430 --> 00:23:57.859
Zsolt Felföldi: If it did exist. So what we do is we prove these two entries with the Merkel proof.

107
00:23:58.740 --> 00:24:08.910
Zsolt Felföldi: So, yeah, the red tree nodes are the proof nodes, like, the yellow ones are the reconstructed hashes.

108
00:24:09.110 --> 00:24:12.079
Zsolt Felföldi: And so we have a middle logarithmic cost.

109
00:24:12.330 --> 00:24:20.200
Zsolt Felföldi: we can prove… prove that… that something does not exist in the table. If it did exist, then…

110
00:24:20.390 --> 00:24:35.049
Zsolt Felföldi: Well, in case of a transaction hash, then probably we don't even really need this table, we could just prove it from the block, but anyways, so, if we want to prove, yeah, I will just go to the next example that will be more interesting.

111
00:24:35.320 --> 00:24:43.929
Zsolt Felföldi: So this is… this is where we also prove, like, things that do exist. So this is… this is a log pattern query.

112
00:24:44.200 --> 00:24:52.030
Zsolt Felföldi: And we are looking for… for a USDT transfer from Bob to anyone.

113
00:24:52.190 --> 00:24:53.910
Zsolt Felföldi: And that's… that's our search.

114
00:24:54.460 --> 00:24:55.699
Zsolt Felföldi: And,

115
00:24:56.730 --> 00:25:06.680
Zsolt Felföldi: Here in this… in this case, there is some room for optimization… heuristic optimization from the part of the prover, but

116
00:25:06.890 --> 00:25:17.689
Zsolt Felföldi: The, the… I mean, generally, it's a good idea to look for, the least popular, item first.

117
00:25:17.830 --> 00:25:19.090
Zsolt Felföldi: And,

118
00:25:19.390 --> 00:25:35.740
Zsolt Felföldi: And actually, if you have a big search table, and now let's assume we are having search tables with hundreds of thousands of entries, and I think even for 64 blocks, it's realistic to talk about more than 100,000 entries. So, yeah,

119
00:25:35.810 --> 00:25:46.410
Zsolt Felföldi: the… if we are looking for USDT, contract address or transfer topic, we are going to have, like, thousands of matches.

120
00:25:46.770 --> 00:25:53.690
Zsolt Felföldi: But even those… so it is possible to just, look up the,

121
00:25:54.050 --> 00:26:10.879
Zsolt Felföldi: range of each of these. I mean, we can also assume that the later topics are less frequent, but if we don't want to have such assumptions, we can just check with the logarithmic cost how many matches we have.

122
00:26:10.880 --> 00:26:17.240
Zsolt Felföldi: Like, here are these… these two lines, it's… so, like, like, we look for address type.

123
00:26:17.300 --> 00:26:19.900
Zsolt Felföldi: and the USDT value.

124
00:26:19.920 --> 00:26:39.519
Zsolt Felföldi: And we can just do, like, this tree search for the first and last entry, and we can already, without reading all the entries, I mean, I'm talking about how the prover does now. So, yeah, the prover can determine the number of matches for USDT, address.

125
00:26:39.520 --> 00:26:44.570
Zsolt Felföldi: For transfer, topic 0, for Bob at topic 1,

126
00:26:44.600 --> 00:26:54.279
Zsolt Felföldi: And the prover can conclude that, like, the least frequent thing that happens is that topic one is Bob.

127
00:26:54.710 --> 00:27:02.800
Zsolt Felföldi: And, and, and here in this case, these four, red lines, they prove that,

128
00:27:04.180 --> 00:27:13.260
Zsolt Felföldi: that, there's exactly these two, cases, then topic one equals Bob, Bob's address.

129
00:27:13.680 --> 00:27:25.139
Zsolt Felföldi: So, yeah, block… both of them in block 42, and one is in the transaction 0 log 1, and the other is in transaction 1 log 0.

130
00:27:25.380 --> 00:27:33.210
Zsolt Felföldi: Which is, like, actually, the second one is the withdrawal, so this is not what… we don't want.

131
00:27:34.030 --> 00:27:48.869
Zsolt Felföldi: So, yeah, and in this case, it's also good to talk… think in terms of exclusion proofs. So, in the end, we are going to prove the actual match, which is, like, this… this…

132
00:27:50.240 --> 00:27:58.680
Zsolt Felföldi: Bob transfers USDT to Alice. This will be the actual match, the actual result, which is in… in transaction 0 log 1.

133
00:27:58.800 --> 00:28:03.019
Zsolt Felföldi: And, we can prove this through the receipts.

134
00:28:03.260 --> 00:28:07.710
Zsolt Felföldi: And this is also why the block hash is proven, because…

135
00:28:08.350 --> 00:28:19.230
Zsolt Felföldi: Yeah, so we also proved that this is the block hash of block 42. This is a convenient way to prove the canonical hash, which might not be so easy if this is an old block.

136
00:28:19.250 --> 00:28:31.339
Zsolt Felföldi: And the prover can use the regular, receipts tree to prove this actual match. And what we need to prove is that others are not matches.

137
00:28:31.340 --> 00:28:39.560
Zsolt Felföldi: So, just checking topic one already leaves us two options, and we now just need to disprove the second one.

138
00:28:39.620 --> 00:28:58.320
Zsolt Felföldi: Which is the withdrawal. So, yeah, an easy way is just to prove that at block 42, transaction 10, topic 0 is withdrawal, which is not what we are looking for. So, yeah, we ruled out the other match, and

139
00:28:59.080 --> 00:29:03.430
Zsolt Felföldi: Yeah, this is all we need to…

140
00:29:03.870 --> 00:29:21.830
Zsolt Felföldi: do a log query, in a single table. So, yeah, and, still… I mean, I mean, I mean, in case of these more complex searches, it's, it's harder to do exact numbers of how expensive a proof is, because it depends on some factors, but,

141
00:29:21.880 --> 00:29:31.060
Zsolt Felföldi: the overhead, additional overhead over the actual matches, that is still more or less, I mean, usually logarithmic, so…

142
00:29:31.470 --> 00:29:36.310
Zsolt Felföldi: So, even if we have to, You know.

143
00:29:37.410 --> 00:29:43.859
Zsolt Felföldi: I mean, anyway, so, so the, so the bigger tables are, are, are always more efficient.

144
00:29:44.240 --> 00:29:48.840
Zsolt Felföldi: And, yeah, this is just, some, some…

145
00:29:49.050 --> 00:30:01.900
Zsolt Felföldi: reasonings about, why I think this whole approach is a good idea, so that we… we put smaller tables in consensus, and, and then we,

146
00:30:02.070 --> 00:30:04.919
Zsolt Felföldi: prove bigger tables with ZK proofs.

147
00:30:05.280 --> 00:30:21.640
Zsolt Felföldi: So, yeah, this is a new thing in this whole design, because originally, with the complex, original EIP7745, I really tried to achieve, that, we have a structure that's easy to update, but also

148
00:30:21.910 --> 00:30:28.380
Zsolt Felföldi: Efficient for low-term history, but yeah, that comes with high complexity and still some trade-offs.

149
00:30:28.580 --> 00:30:34.870
Zsolt Felföldi: And, and… Yeah, so, I mean, I mean, if, if,

150
00:30:36.790 --> 00:30:43.079
Zsolt Felföldi: I think it's obvious that processing very big tables in consensus has some drawbacks.

151
00:30:43.330 --> 00:30:52.589
Zsolt Felföldi: But also, if we… if we process everything with ZK proofs, then we don't have the last few blocks, or even last few hundred blocks.

152
00:30:53.000 --> 00:30:54.090
Zsolt Felföldi: And,

153
00:30:54.300 --> 00:31:02.309
Zsolt Felföldi: And for all of these, we have to just use the complete block receipts to prove anything, so…

154
00:31:02.610 --> 00:31:11.070
Zsolt Felföldi: like, if we can generate a ZK proof, every hour, which is, yeah, probably still already kind of expensive.

155
00:31:11.260 --> 00:31:20.250
Zsolt Felföldi: But then… then just proving the events in the last hour, that will be, like, 15 or 20 megabytes, which is already kind of expensive.

156
00:31:20.390 --> 00:31:34.930
Zsolt Felföldi: And, and if we want to, like, use this whole thing for, for, for, off-chain or cross-chain, event proofs, which I think will be, yeah, an important…

157
00:31:35.220 --> 00:31:49.920
Zsolt Felföldi: thing for future scalability, then this is… this is prohibitive, so even not having the… the last block indexed is bad. Actually, that's usually the most… most interesting block, probably, for these use cases.

158
00:31:50.460 --> 00:31:54.050
Zsolt Felföldi: And, and yeah, so,

159
00:31:54.490 --> 00:32:01.390
Zsolt Felföldi: But if we just process the big tables with long delay, then…

160
00:32:02.030 --> 00:32:07.150
Zsolt Felföldi: These proofs can also be built in a collaborative way, like,

161
00:32:07.150 --> 00:32:27.419
Zsolt Felföldi: I have no design for the proofs yet, but I think with this design, it's reasonably simple, because it's just lists of 64-byte entries ordered, and we have some smaller tables, and we have one bigger table, and we can just generate proofs that prove

162
00:32:27.420 --> 00:32:38.449
Zsolt Felföldi: At certain smaller index ranges that the merging… the merge sort is performed correctly, so… so actually it's not going to be a super complex proof.

163
00:32:39.370 --> 00:32:49.320
Zsolt Felföldi: also the ZK proof does not need to care about all the receipt encoding and all the stuff, because that's done in consensus, so I think this is…

164
00:32:49.690 --> 00:32:57.939
Zsolt Felföldi: Also, with this approach, doing the proofs is also easier technically, and also a lot cheaper.

165
00:32:58.070 --> 00:33:04.100
Zsolt Felföldi: So, yeah. And, yeah, that's pretty much it.

166
00:33:04.370 --> 00:33:21.899
Zsolt Felföldi: Yeah, there's still a few things I think we can debate, like, I just said now that, okay, let's do 64 blocks, the tables in consensus, but yeah, maybe we could do more, and, and then we have even, like, this whole…

167
00:33:21.940 --> 00:33:27.730
Zsolt Felföldi: The proofs will be even cheaper, because, yeah, we…

168
00:33:27.930 --> 00:33:45.790
Zsolt Felföldi: we have even more time to generate them, but yeah, this is just… just finding the… about finding the optimum, and also the hashing scheme. Now I just, yeah, said that let's use the SSZ list localization, but we don't necessarily have to use it.

169
00:33:45.790 --> 00:33:50.030
Zsolt Felföldi: And more specifically, I'm honestly not sure about,

170
00:33:50.350 --> 00:33:57.750
Zsolt Felföldi: What are the most ZK-friendly hashes now? Maybe not SHA-2.

171
00:33:58.140 --> 00:34:02.090
Zsolt Felföldi: But, yeah, so, so we can, we can, we can figure out,

172
00:34:03.320 --> 00:34:16.739
Zsolt Felföldi: whether we should use another hash function that's efficient both on CPU and ZK proofs, and also, yeah, so this, this, this 64-byte encoding,

173
00:34:16.870 --> 00:34:28.030
Zsolt Felföldi: In case of Shattoo, I think it's more efficient to use something that's, like, slightly smaller than 64 bytes, because, yeah, anyways, these are just minor details.

174
00:34:28.460 --> 00:34:32.780
Zsolt Felföldi: But, yeah, so this is… this is… this is… this is my current proposal.

175
00:34:36.620 --> 00:34:38.060
Zsolt Felföldi: The…

176
00:34:44.279 --> 00:34:52.489
Łukasz Rozmej: Yeah, let me ask a question. So, this is now, with this design, not effective to store the whole history?

177
00:34:54.000 --> 00:34:54.630
Zsolt Felföldi: Ugh.

178
00:34:54.630 --> 00:34:55.779
Łukasz Rozmej: football history.

179
00:34:56.179 --> 00:35:10.239
Zsolt Felföldi: Well, I mean, I mean, the tables are, effective. I mean, I mean, I mean, the way I imagine this is that, the cons, so the consensus is generating 64 block tables, and,

180
00:35:10.349 --> 00:35:13.059
Zsolt Felföldi: And, and, and, yeah.

181
00:35:13.849 --> 00:35:28.239
Zsolt Felföldi: if we… if we… if we can ZK approve bigger tables, we can create tables of a million blocks, or I don't know. I mean, I mean, I mean, I mean, this, this whole thing, if we just, always, merge

182
00:35:28.239 --> 00:35:35.119
Zsolt Felföldi: two or four smaller tables into a bigger one. The tables does not necessarily have to be,

183
00:35:35.119 --> 00:35:46.099
Zsolt Felföldi: power of two-sized. I mean, it's just the number of blocks and some events, and the number of events will just be some random number anyway, but but it's just, yeah.

184
00:35:46.189 --> 00:36:01.409
Zsolt Felföldi: convenient to think about, but yeah, so we can… we can keep merging the tables, and in the end, we will have a logarithmic number of tables, and and… and… and we can even have, I don't know,

185
00:36:01.629 --> 00:36:09.099
Zsolt Felföldi: One big table for, like, most of the old chain history, and a few smaller tables.

186
00:36:09.809 --> 00:36:11.189
Zsolt Felföldi: At the end

187
00:36:11.389 --> 00:36:25.629
Zsolt Felföldi: And, and, and, and this, so, so, so if we do have big tables, then this is, this is significantly more efficient than my original, proposal. So,

188
00:36:26.279 --> 00:36:33.589
Zsolt Felföldi: I did some, I don't have… I don't have… don't have calculations in these slides yet, but,

189
00:36:34.109 --> 00:36:43.859
Zsolt Felföldi: But, but, but in general, if we just, Let's just… Yo.

190
00:36:44.559 --> 00:36:45.949
Zsolt Felföldi: Go back.

191
00:36:46.889 --> 00:36:49.049
Zsolt Felföldi: On this? Why did I,

192
00:36:49.859 --> 00:36:59.609
Zsolt Felföldi: Yeah, here I did some calculation at the, like, you know, at the end. So, proof cost per index table, and

193
00:36:59.849 --> 00:37:17.529
Zsolt Felföldi: Yeah, for a bulkwork estimate, it's usually a good benchmark to think about just a single exclusion proof per table, and obviously more complex searches will be a few times that, but,

194
00:37:18.019 --> 00:37:21.999
Zsolt Felföldi: But yeah, so this can be our baseline estimate.

195
00:37:22.119 --> 00:37:35.229
Zsolt Felföldi: And, yeah, so proving… one exclusion proof is… requires proving these two red lines. So, with a compact encoding, one… one entry can be 40-something bytes.

196
00:37:35.439 --> 00:37:44.649
Zsolt Felföldi: And also, we have, one proof node per, tree level, so this is… like,

197
00:37:45.129 --> 00:37:49.249
Zsolt Felföldi: This is a very small table, so we have, like, 5,

198
00:37:50.489 --> 00:37:59.239
Zsolt Felföldi: Five levels, and if we generate a huge table that covers, like, most of the history.

199
00:37:59.549 --> 00:38:17.059
Zsolt Felföldi: then… and… and, I mean, it's a merge sort, so it can be efficiently processed in database and everything, so it's… it's not… I mean, it has some costs, but it's… it's… it's doable that… to… to… to generate most of the… put most of the history in one table, then…

200
00:38:17.499 --> 00:38:26.599
Zsolt Felföldi: then the single exclusion proof will be, let's just say, I think, I think the number of, these entries is…

201
00:38:26.919 --> 00:38:37.489
Zsolt Felföldi: Somewhere in the 20 billion range now, so the logarithm of that is, 35 or something?

202
00:38:37.879 --> 00:38:45.549
Zsolt Felföldi: So, like, a single exclusion proof is somewhat, like, like, little over 1KB. I mean, it's not so bad.

203
00:38:45.769 --> 00:38:49.239
Zsolt Felföldi: And, that cover… can cover, like,

204
00:38:51.579 --> 00:38:59.389
Zsolt Felföldi: more than 10 million blocks, or I don't know. And and… and actually, the more expensive thing is… is… is…

205
00:38:59.789 --> 00:39:06.859
Zsolt Felföldi: Like, like, if we have, have these, these, these, these, exponentially smaller tables, then, then…

206
00:39:07.089 --> 00:39:12.989
Zsolt Felföldi: The proof cost will increase roughly logarithmically, so…

207
00:39:13.079 --> 00:39:29.319
Zsolt Felföldi: Let's assume we have, like, one 35-level table, and one 34-level table, and so on and so on, and we have smaller tables, and the full history proof can be, like, somewhere around… somewhere around 40 kilobytes.

208
00:39:30.199 --> 00:39:33.529
Zsolt Felföldi: And, I mean, this is… this is a single exclusion proof.

209
00:39:33.669 --> 00:39:43.789
Zsolt Felföldi: more complex proof can be a few hundred kilobytes, but yeah, I mean, for a full history proof, that's still better than, I don't know, 600 gigabytes, so yeah.

210
00:39:46.289 --> 00:39:47.809
Meek Msaki: Wait, can I ask you a question?

211
00:39:48.170 --> 00:39:48.940
Zsolt Felföldi: Yes, sure.

212
00:39:49.350 --> 00:39:54.809
Meek Msaki: So, so, are you saying, like, this is more efficient than foam filters?

213
00:39:56.620 --> 00:39:59.880
Meek Msaki: I just had to ask that, like…

214
00:40:04.810 --> 00:40:08.470
Meek Msaki: the lookup, because I think my understanding of, like, bloom filters.

215
00:40:08.570 --> 00:40:10.919
Meek Msaki: They kind of allow you to, like, see if…

216
00:40:11.150 --> 00:40:24.479
Meek Msaki: like, you know, it's, like, kind of like a lookup thing. I'm not sure on, like, the exact technical details, but I was just wondering, like, is the improvement here in terms of, like, more storing or lookups?

217
00:40:24.480 --> 00:40:31.279
Łukasz Rozmej: This is… this is less efficient than big enough bloom filters, the whole thing here is about proving.

218
00:40:31.640 --> 00:40:35.169
Meek Msaki: Oh, it's about proving, like, inclusion, or just…

219
00:40:35.680 --> 00:40:36.890
Zsolt Felföldi: Wait.

220
00:40:37.840 --> 00:40:38.460
Meek Msaki: Okay.

221
00:40:38.750 --> 00:40:50.259
Zsolt Felföldi: Yeah, so inclusion is usually easier. So, so, so, this is, this is mostly about proving the complete set of, matches for certain criteria. And, well, if…

222
00:40:50.300 --> 00:41:03.860
Zsolt Felföldi: if you're asking about bloom filters, so the… well, I mean, it depends on how we… how we use bloom filters. I mean, the bloom filters we have now are practically useless, so yeah, it's definitely better than that.

223
00:41:04.100 --> 00:41:11.020
Zsolt Felföldi: I did some, calculations of, I mean, I mean, I mean, if you, if you, if you, if you have,

224
00:41:13.660 --> 00:41:23.010
Zsolt Felföldi: No, I really don't think you can even come close to this efficiency with any blow-filter-based design.

225
00:41:23.300 --> 00:41:26.000
Zsolt Felföldi: I mean, I mean, I mean…

226
00:41:27.230 --> 00:41:33.000
Zsolt Felföldi: you could have some, some, some huge room filter for, for, for, like,

227
00:41:33.890 --> 00:41:45.080
Zsolt Felföldi: many block region… I mean, I mean, if you have one bloom filter per block, then you're already way worse, because… because… so right now, with…

228
00:41:45.080 --> 00:42:00.879
Zsolt Felföldi: if we just used bigger bloom filters instead of what we have now in consensus, so, like, instead of using a 2,000-bit bloom filter, we could use something like, I don't know, 100,000-bit bloom filter.

229
00:42:00.880 --> 00:42:09.460
Zsolt Felföldi: So… then we would still have, like, 100,000 bits per block. I mean, yeah, that's… that's way worse than…

230
00:42:09.600 --> 00:42:22.389
Zsolt Felföldi: what we have here. So, here we can have one table of, like, 10 million blocks, and we can prove something in it with just one kilobyte. So, yeah, I think…

231
00:42:23.240 --> 00:42:29.370
Zsolt Felföldi: This is, this is, this is, this is the most efficient… version.

232
00:42:30.270 --> 00:42:33.189
Zsolt Felföldi: I could think of until now, so yeah.

233
00:42:35.260 --> 00:42:39.429
Łukasz Rozmej: Do we have to sort by type?

234
00:42:40.360 --> 00:42:44.920
Zsolt Felföldi: Well, you don't have to, I think it makes sense.

235
00:42:45.220 --> 00:42:50.829
Zsolt Felföldi: Yeah, so the previous version did not do that. I did that since then.

236
00:42:51.070 --> 00:42:54.449
Zsolt Felföldi: One option is to, I mean.

237
00:42:55.730 --> 00:43:01.990
Łukasz Rozmej: Well, why I'm asking that? Because I'm asking, can we… Have this kind of structure.

238
00:43:02.120 --> 00:43:07.640
Łukasz Rozmej: And use it as our main log,

239
00:43:08.420 --> 00:43:14.870
Łukasz Rozmej: storage too, right? So don't have to duplicate this data from the receipts.

240
00:43:15.640 --> 00:43:20.630
Łukasz Rozmej: But kind of unified with the receipts, and store it just once.

241
00:43:20.950 --> 00:43:27.369
Zsolt Felföldi: Well, okay, so yeah, this is an interesting question, and, and, and,

242
00:43:27.590 --> 00:43:30.479
Zsolt Felföldi: The thing is that,

243
00:43:31.170 --> 00:43:43.310
Zsolt Felföldi: Yeah, the receipts, they… they… so it's… it's… it's… it's maybe… probably, we have to hash the same data in two different ways, anyways. So,

244
00:43:43.340 --> 00:44:00.670
Zsolt Felföldi: So this design… I mean, in this version, I dropped that linear log value index thing that I had in previous designs. I mean, it has some efficiency advantages, but, but in this version, if we use

245
00:44:00.870 --> 00:44:20.100
Zsolt Felföldi: ZK-proven tables and everything, then maybe it's not so important to be the most efficient, so maybe simplicity will help. But anyways, in those designs, I used a separate index entrust table. Now, I don't have that, so I just, propose using the actual receipts for inclusion proofs. So the thing is that,

246
00:44:21.390 --> 00:44:27.740
Zsolt Felföldi: with the… with… so the receipts are, organized chronologically. And,

247
00:44:28.030 --> 00:44:40.199
Zsolt Felföldi: And probably you also need that. So, in this case, now, now these, these, these, search values are, organized, yeah, by content. And,

248
00:44:40.760 --> 00:44:47.660
Zsolt Felföldi: You can look up this… so there's this example, like, like, USDT transfer bulk to anyone.

249
00:44:47.810 --> 00:44:49.749
Zsolt Felföldi: And yes, you can look up.

250
00:44:49.750 --> 00:45:08.019
Zsolt Felföldi: you can look up USDT, you can look up Bob, you can look up transfer, you can match them together, but it will not be easy to find out that it… topic 2 is Alice, so this… this actual… so… so it will not be easy to reconstruct the actual log, because this hashing

251
00:45:08.020 --> 00:45:10.650
Zsolt Felföldi: It's organized by content, and now…

252
00:45:10.870 --> 00:45:17.370
Zsolt Felföldi: now finding something by inclusion position is hard. So, I think,

253
00:45:18.020 --> 00:45:21.160
Zsolt Felföldi: We do need to, hash

254
00:45:21.420 --> 00:45:25.879
Zsolt Felföldi: Hash, hash, all the events, both chronologically.

255
00:45:26.000 --> 00:45:32.179
Zsolt Felföldi: which the receipts do. And, and also, by content.

256
00:45:32.410 --> 00:45:42.840
Zsolt Felföldi: And it's an implementation thing, whether we want to deduplicate the actual content. So, it is possible to

257
00:45:42.840 --> 00:45:57.770
Zsolt Felföldi: store these tables locally in a way that you don't actually store the type and the value. You do the sorting, and you just store the position information, and you can look it up from the receipts.

258
00:45:58.200 --> 00:45:59.670
Zsolt Felföldi: So,

259
00:46:01.130 --> 00:46:15.109
Zsolt Felföldi: It's still some extra data to store, because it's a different ordering, and yeah, that's what you have to do if you want to… more efficiency, but you don't necessarily have to duplicate the actual contents.

260
00:46:16.270 --> 00:46:22.020
Zsolt Felföldi: But I think, in any reasonable setup, we do need to…

261
00:46:22.170 --> 00:46:26.269
Zsolt Felföldi: Hash it, hash, hash them, both.

262
00:46:26.720 --> 00:46:30.210
Zsolt Felföldi: In, in, in a, in a content,

263
00:46:30.660 --> 00:46:37.680
Zsolt Felföldi: address way, and also… or content-ordered way, and… or… and also a chronological way. So, yeah,

264
00:46:39.070 --> 00:46:43.330
Zsolt Felföldi: with this design, I think it's best to, keep the receipts.

265
00:46:43.620 --> 00:46:59.440
Zsolt Felföldi: I mean, I did have this other version where I had the index entry street, which does… did the, chronological hashing, so in that case, it would be possible to, drop the receipts and,

266
00:46:59.440 --> 00:47:07.130
Zsolt Felföldi: And have, like, a different, tree representation, but it will still be another way of tree hashing. So, yeah.

267
00:47:07.300 --> 00:47:16.420
Zsolt Felföldi: I mean… This is… this is, this is, this is probably the smallest change we can do, and

268
00:47:17.380 --> 00:47:24.079
Zsolt Felföldi: But anyways, yeah, I, I think, I think, I think, I think, I think it's important to have the two hashings.

269
00:47:27.450 --> 00:47:32.480
Meek Msaki: Also, quick question, this… are these, like, different tables, or is this just one table?

270
00:47:33.400 --> 00:47:40.499
Zsolt Felföldi: So, what I show in this example is one table. So, yeah, but this is…

271
00:47:40.710 --> 00:47:49.309
Zsolt Felföldi: So this is, this is, this is this, I had this example with blocks 40 to 43 with this, like.

272
00:47:49.950 --> 00:47:54.730
Zsolt Felföldi: or events, and this is… this is what I used in all examples.

273
00:47:55.200 --> 00:47:59.180
Zsolt Felföldi: So, this is the table, and yeah, if I just…

274
00:48:00.570 --> 00:48:06.480
Zsolt Felföldi: switch back and forth between these two tables, then it's obvious. It's just… Yeah.

275
00:48:06.860 --> 00:48:09.529
Zsolt Felföldi: The difference is what we prove from that.

276
00:48:09.690 --> 00:48:10.600
Zsolt Felföldi: Let's yell.

277
00:48:12.200 --> 00:48:20.959
Meek Msaki: No, I was saying, like, in terms of, like, let's say, every single, like, height, is it almost like looking up into a new table?

278
00:48:22.980 --> 00:48:30.180
Zsolt Felföldi: Wait, so yeah, do you have multiple tables, so, Yeah, there's…

279
00:48:30.180 --> 00:48:35.299
Meek Msaki: So you have the block number table, mem is a table for log index.

280
00:48:35.300 --> 00:48:42.210
Zsolt Felföldi: Oh, no, no, no, no, not necessarily. No, this can be in one table. So, yeah, I mean, I mean, I mean,

281
00:48:43.010 --> 00:48:59.489
Zsolt Felföldi: I think, I think it makes sense. Now, if we do have an index, it makes sense to do all these things, and I think, there's no advantage of putting them in separate tables. We could, but… I mean, I mean, I mean, putting the type first.

282
00:48:59.660 --> 00:49:19.569
Zsolt Felföldi: this will mean that block hashes will occupy a continuous subtree, and transaction hashes will occupy a continuous subtree, so efficiency-wise, it's almost the same as having separate tables for the different types of entries, but I see no reason to really, like.

283
00:49:19.570 --> 00:49:24.469
Zsolt Felföldi: create many tables per block, you know.

284
00:49:24.630 --> 00:49:26.260
Zsolt Felföldi: It's just, I think, easier.

285
00:49:26.460 --> 00:49:33.020
Meek Msaki: So it's… the duplication is not, like, a problem, because, like, there's a lot of, like, duplicated values and stuff like that.

286
00:49:34.950 --> 00:49:46.340
Zsolt Felföldi: So, sorry, I mean, I mean, every, every value is duplicated here, but, yeah, in the database representation, you don't necessarily have to

287
00:49:46.810 --> 00:49:53.060
Zsolt Felföldi: have them… store them twice. It's just, yeah, let's… No.

288
00:49:53.910 --> 00:50:00.570
Zsolt Felföldi: Okay. It's just… just the position information that you have to store,

289
00:50:01.380 --> 00:50:04.499
Zsolt Felföldi: When it's, sorted by content, yeah.

290
00:50:05.980 --> 00:50:08.020
Meek Msaki: After sorting it by content, yeah.

291
00:50:08.970 --> 00:50:11.250
Meek Msaki: Okay, so did… okay, alright.

292
00:50:13.020 --> 00:50:19.889
Zsolt Felföldi: Yeah, still, it's, I mean, I mean, probably,

293
00:50:21.680 --> 00:50:30.450
Zsolt Felföldi: For, for the, for the, for those, for the infra providers who want to, generate, proofs.

294
00:50:30.590 --> 00:50:32.900
Zsolt Felföldi: They will probably…

295
00:50:33.650 --> 00:50:39.570
Zsolt Felföldi: I mean, I mean, I mean, I would, I, I, I, I would, I would, actually duplicate this…

296
00:50:39.650 --> 00:50:44.390
Zsolt Felföldi: this, these, these values, which is, like, I mean…

297
00:50:44.440 --> 00:51:01.240
Zsolt Felföldi: it has some cost, but if you're running an infra provider node, then what you want is to be efficient, and yeah, if you, if you deduplicate the, the values, then,

298
00:51:01.400 --> 00:51:09.019
Zsolt Felföldi: Yeah, you want to generate a proof, and, you have to, like, like, look up all these, these,

299
00:51:09.690 --> 00:51:29.310
Zsolt Felföldi: these values from very different places, and it's not super efficient, so if you want to be efficient at generating proofs, then I would say probably it's best to just duplicate it, but I mean, if you are running a node for this purpose, then, I mean, it's an affordable cost.

300
00:51:30.480 --> 00:51:37.300
Zsolt Felföldi: And for those who don't want to generate, like, long-term historic proofs, just, I don't know.

301
00:51:37.840 --> 00:51:52.600
Zsolt Felföldi: generate the consensus stuff, they really don't need to deal with big tables, so those who just generate the consensus can mostly just keep those tables that have non-finalized

302
00:51:52.630 --> 00:52:03.189
Zsolt Felföldi: parts, so all the finalized tables can be discarded if you just want to generate the consensus, so then… then the storage efficiency is really not an issue.

303
00:52:03.570 --> 00:52:10.420
Zsolt Felföldi: And yeah, if you want to use it, then… Then probably, you don't.

304
00:52:10.660 --> 00:52:12.870
Zsolt Felföldi: You, you, you, you can just duplicate.

305
00:52:13.050 --> 00:52:23.310
Zsolt Felföldi: Maybe if you want to use this structure locally, just for local search, then you can… because you're running your own full node, and you just want to,

306
00:52:24.800 --> 00:52:43.579
Zsolt Felföldi: search for yourself, then you can… you can… you can… you can generate these tables for… for yourself, and… and you don't even need ZK proofs, because you know they are correct, because you generated them. And then, maybe, maybe for local use, it might be a good, compromise to,

307
00:52:43.710 --> 00:52:59.450
Zsolt Felföldi: to store the final tables with just the position info, and then the lookup is a little bit more expensive, but the whole structure will not cost another 600GB, more like, I don't know, less than 100, so… yeah, I mean…

308
00:53:00.180 --> 00:53:08.780
Zsolt Felföldi: the index does have some costs if you want to index the entire history and do quick lookups, I mean, it will have some storage costs, but yeah, it's optional.

309
00:53:30.990 --> 00:53:33.000
Meek Msaki: Alright, thank you, I think I'm gonna hop off.

310
00:53:34.120 --> 00:53:34.900
Zsolt Felföldi: Alright.

311
00:53:35.120 --> 00:53:36.489
Zsolt Felföldi: Okay, thanks for coming.

312
00:53:46.550 --> 00:53:47.430
Zsolt Felföldi: Yo.

313
00:53:48.350 --> 00:53:51.289
Zsolt Felföldi: Okay, anyways, this is…

314
00:53:51.570 --> 00:53:54.870
Zsolt Felföldi: pretty much what I wanted to do.

315
00:53:55.300 --> 00:53:57.120
Zsolt Felföldi: Talk about today?

316
00:53:57.320 --> 00:53:58.789
Zsolt Felföldi: Any more questions?

317
00:54:00.710 --> 00:54:02.119
Sixto Palacios: Oh, thank you.

318
00:54:02.820 --> 00:54:03.810
Zsolt Felföldi: Okay.

319
00:54:04.820 --> 00:54:11.649
Zsolt Felföldi: Then I think we can call it a day, and yeah, by the way, just for the quick feedback,

320
00:54:12.700 --> 00:54:22.579
Zsolt Felföldi: Do you… how… how do you relate to the complexity of this? So, does it sound very complex, or now this… does this sound like something manageable, more manageable?

321
00:54:23.670 --> 00:54:30.690
Sixto Palacios: No, I don't know, complex, is, is, put…

322
00:54:31.770 --> 00:54:35.670
Sixto Palacios: Some attention, but it's so comprehensible.

323
00:54:36.830 --> 00:54:37.640
Zsolt Felföldi: Okay.

324
00:54:39.210 --> 00:54:40.490
Zsolt Felföldi: Alright.

325
00:54:43.910 --> 00:54:45.740
Zsolt Felföldi: Okay, so,

326
00:54:50.180 --> 00:54:51.500
Zsolt Felföldi: Okay.

327
00:54:52.400 --> 00:54:54.120
Zsolt Felföldi: So, should we call it a day, then?

328
00:54:56.780 --> 00:54:57.820
Sixto Palacios: Nope.

329
00:54:58.360 --> 00:55:00.010
Zsolt Felföldi: Do you have more, Chris? Alright.

330
00:55:02.480 --> 00:55:04.319
Sixto Palacios: Thank you so much, bye-bye.

331
00:55:04.320 --> 00:55:05.260
Zsolt Felföldi: Thank you, bye-bye.

